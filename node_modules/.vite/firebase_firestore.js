import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-DCNKQXVC.js";
import "./chunk-G5FOCCER.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var N2 = "9.6.7";
var x2 = new Logger("@firebase/firestore");
function k2() {
  return x2.logLevel;
}
function O2(t2) {
  x2.setLogLevel(t2);
}
function M2(t2, ...e) {
  if (x2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B2);
    x2.debug(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (x2.logLevel <= LogLevel.ERROR) {
    const n = e.map(B2);
    x2.error(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (x2.logLevel <= LogLevel.WARN) {
    const n = e.map(B2);
    x2.warn(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function B2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${N2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw $(e), new Error(e);
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  t2 || L2();
}
function K2(t2, e) {
  return t2;
}
var G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var j = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var Q2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new Q2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new Q2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      M2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (M2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new Q2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (M2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e) {
    const n = (t3) => {
      t3.error != null && M2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.p;
      return this.p = t3.token, M2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      M2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s(t3) : M2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U2(typeof t3.token == "string"), this.p = t3.token, new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var et = class {
  getToken() {
    return Promise.resolve(new Z2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
var nt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.I(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  I(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function st(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
nt.A = -1;
var it = class {
  static R() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = st(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function rt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function ot(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ct(t2) {
  return t2 + "\0";
}
var ut = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new j(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new j(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new j(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new j(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return ut.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return ut.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new ut(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? rt(this.nanoseconds, t2.nanoseconds) : rt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var at = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new at(t2);
  }
  static min() {
    return new at(new ut(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ht(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var dt = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return dt.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof dt ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var _t = class extends dt {
  construct(t2, e, n) {
    return new _t(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new j(G.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new _t(e);
  }
  static emptyPath() {
    return new _t([]);
  }
};
var wt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var mt = class extends dt {
  construct(t2, e, n) {
    return new mt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return wt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), mt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new mt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new j(G.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new j(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new j(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new j(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new mt(e);
  }
  static emptyPath() {
    return new mt([]);
  }
};
var gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(mt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return ot(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function yt() {
  return typeof atob != "undefined";
}
var pt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new pt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new pt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return rt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
pt.EMPTY_BYTE_STRING = new pt("");
var It = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Et(t2) {
  if (U2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = It.exec(t2);
    if (U2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Tt(t2.seconds),
    nanos: Tt(t2.nanos)
  };
}
function Tt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function At(t2) {
  return typeof t2 == "string" ? pt.fromBase64String(t2) : pt.fromUint8Array(t2);
}
function Rt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Pt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Rt(e) ? Pt(e) : e;
}
function bt(t2) {
  const e = Et(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new ut(e.seconds, e.nanos);
}
var vt = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = c;
  }
};
var Vt = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new Vt("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof Vt && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function St(t2) {
  return t2 == null;
}
function Dt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Ct(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Dt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var Nt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new Nt(_t.fromString(t2));
  }
  static fromName(t2) {
    return new Nt(_t.fromString(t2).popFirst(5));
  }
  static empty() {
    return new Nt(_t.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return t2 !== null && _t.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return _t.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new Nt(new _t(t2.slice()));
  }
};
var xt = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max___"
      }
    }
  }
};
function kt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Rt(t2) ? 4 : 10 : L2();
}
function Ot(t2, e) {
  if (t2 === e)
    return true;
  const n = kt(t2);
  if (n !== kt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return bt(t2).isEqual(bt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Et(t3.timestampValue), s = Et(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return At(t3.bytesValue).isEqual(At(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Tt(t3.geoPointValue.latitude) === Tt(e2.geoPointValue.latitude) && Tt(t3.geoPointValue.longitude) === Tt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Tt(t3.integerValue) === Tt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Tt(t3.doubleValue), s = Tt(e2.doubleValue);
          return n2 === s ? Dt(n2) === Dt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return ot(t2.arrayValue.values || [], e.arrayValue.values || [], Ot);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ht(n2) !== ht(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Ot(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function Mt(t2, e) {
  return (t2.values || []).find((t3) => Ot(t3, e)) !== void 0;
}
function $t(t2, e) {
  if (t2 === e)
    return 0;
  const n = kt(t2), s = kt(e);
  if (n !== s)
    return rt(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return rt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Tt(t3.integerValue || t3.doubleValue), s2 = Tt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Ft(t2.timestampValue, e.timestampValue);
    case 4:
      return Ft(bt(t2), bt(e));
    case 5:
      return rt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = At(t3), s2 = At(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = rt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = rt(Tt(t3.latitude), Tt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return rt(Tt(t3.longitude), Tt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = $t(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = rt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = $t(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return rt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function Ft(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return rt(t2, e);
  const n = Et(t2), s = Et(e), i = rt(n.seconds, s.seconds);
  return i !== 0 ? i : rt(n.nanos, s.nanos);
}
function Bt(t2) {
  return Lt(t2);
}
function Lt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Et(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? At(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Nt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Lt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Lt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function Ut(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function qt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Kt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Gt(t2) {
  return !!t2 && "nullValue" in t2;
}
function jt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Qt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Wt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Wt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Wt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var zt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new zt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Qt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Wt(e);
  }
  setAll(t2) {
    let e = mt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Wt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Qt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Ot(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Qt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new zt(Wt(this.value));
  }
};
function Ht(t2) {
  const e = [];
  return lt(t2.fields, (t3, n) => {
    const s = new mt([t3]);
    if (Qt(n)) {
      const t4 = Ht(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new gt(e);
}
var Jt = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new Jt(t2, 0, at.min(), at.min(), zt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Jt(t2, 1, e, at.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new Jt(t2, 2, e, at.min(), zt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Jt(t2, 3, e, at.min(), zt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = zt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = zt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Jt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new Jt(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Yt = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
Yt.UNKNOWN_ID = -1;
var Xt = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
var Zt = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new Zt(0, te.min());
  }
};
var te = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new te(at.min(), Nt.empty(), -1);
  }
};
var ee = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.P = null;
  }
};
function ne(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new ee(t2, e, n, s, i, r, o);
}
function se(t2) {
  const e = K2(t2);
  if (e.P === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + Bt(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), St(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => Bt(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => Bt(t4)).join(",")), e.P = t3;
  }
  return e.P;
}
function ie(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Bt(e2.value)}`;
    var e2;
  }).join(", ")}]`), St(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => Bt(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => Bt(t3)).join(",")), `Target(${e})`;
}
function re(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ye(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Ot(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!Ie(t2.startAt, e.startAt) && Ie(t2.endAt, e.endAt)));
}
function oe(t2) {
  return Nt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var ce = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.v(t2, e, n) : new ue(t2, e, n) : e === "array-contains" ? new fe(t2, n) : e === "in" ? new de(t2, n) : e === "not-in" ? new _e(t2, n) : e === "array-contains-any" ? new we(t2, n) : new ce(t2, e, n);
  }
  static v(t2, e, n) {
    return e === "in" ? new ae(t2, n) : new he(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.V($t(e, this.value)) : e !== null && kt(this.value) === kt(e) && this.V($t(e, this.value));
  }
  V(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  S() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var ue = class extends ce {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = Nt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = Nt.comparator(t2.key, this.key);
    return this.V(e);
  }
};
var ae = class extends ce {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = le("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var he = class extends ce {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = le("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function le(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Nt.fromName(t3.referenceValue));
}
var fe = class extends ce {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Kt(e) && Mt(e.arrayValue, this.value);
  }
};
var de = class extends ce {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && Mt(this.value.arrayValue, e);
  }
};
var _e = class extends ce {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Mt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !Mt(this.value.arrayValue, e);
  }
};
var we = class extends ce {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Kt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Mt(this.value.arrayValue, t3));
  }
};
var me = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var ge = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ye(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function pe(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = Nt.comparator(Nt.fromName(o.referenceValue), n.key);
    else {
      s = $t(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return s;
}
function Ie(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Ot(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var Ee = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, c = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = c, this.D = null, this.C = null, this.startAt, this.endAt;
  }
};
function Te(t2, e, n, s, i, r, o, c) {
  return new Ee(t2, e, n, s, i, r, o, c);
}
function Ae(t2) {
  return new Ee(t2);
}
function Re(t2) {
  return !St(t2.limit) && t2.limitType === "F";
}
function Pe(t2) {
  return !St(t2.limit) && t2.limitType === "L";
}
function be(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function ve(t2) {
  for (const e of t2.filters)
    if (e.S())
      return e.field;
  return null;
}
function Ve(t2) {
  return t2.collectionGroup !== null;
}
function Se(t2) {
  const e = K2(t2);
  if (e.D === null) {
    e.D = [];
    const t3 = ve(e), n = be(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.D.push(new ge(t3)), e.D.push(new ge(mt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.D.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.D.push(new ge(mt.keyField(), t5));
      }
    }
  }
  return e.D;
}
function De(t2) {
  const e = K2(t2);
  if (!e.C)
    if (e.limitType === "F")
      e.C = ne(e.path, e.collectionGroup, Se(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Se(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new ge(n2.field, e2));
      }
      const n = e.endAt ? new me(e.endAt.position, !e.endAt.inclusive) : null, s = e.startAt ? new me(e.startAt.position, !e.startAt.inclusive) : null;
      e.C = ne(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.C;
}
function Ce(t2, e, n) {
  return new Ee(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Ne(t2, e) {
  return re(De(t2), De(e)) && t2.limitType === e.limitType;
}
function xe(t2) {
  return `${se(De(t2))}|lt:${t2.limitType}`;
}
function ke(t2) {
  return `Query(target=${ie(De(t2))}; limitType=${t2.limitType})`;
}
function Oe(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Nt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = pe(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, Se(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = pe(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, Se(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function Me(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Se(t2)) {
      const t3 = $e(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function $e(t2, e, n) {
  const s = t2.field.isKeyField() ? Nt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? $t(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function Fe(t2, e) {
  if (t2.N) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Dt(e) ? "-0" : e
  };
}
function Be(t2) {
  return {
    integerValue: "" + t2
  };
}
function Le(t2, e) {
  return Ct(e) ? Be(e) : Fe(t2, e);
}
var Ue = class {
  constructor() {
    this._ = void 0;
  }
};
function qe(t2, e, n) {
  return t2 instanceof je ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Qe ? We(t2, e) : t2 instanceof ze ? He(t2, e) : function(t3, e2) {
    const n2 = Ge(t3, e2), s = Ye(n2) + Ye(t3.k);
    return qt(n2) && qt(t3.k) ? Be(s) : Fe(t3.O, s);
  }(t2, e);
}
function Ke(t2, e, n) {
  return t2 instanceof Qe ? We(t2, e) : t2 instanceof ze ? He(t2, e) : n;
}
function Ge(t2, e) {
  return t2 instanceof Je ? qt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var je = class extends Ue {
};
var Qe = class extends Ue {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function We(t2, e) {
  const n = Xe(e);
  for (const e2 of t2.elements)
    n.some((t3) => Ot(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var ze = class extends Ue {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function He(t2, e) {
  let n = Xe(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Ot(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Je = class extends Ue {
  constructor(t2, e) {
    super(), this.O = t2, this.k = e;
  }
};
function Ye(t2) {
  return Tt(t2.integerValue || t2.doubleValue);
}
function Xe(t2) {
  return Kt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var Ze = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function tn(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Qe && e2 instanceof Qe || t3 instanceof ze && e2 instanceof ze ? ot(t3.elements, e2.elements, Ot) : t3 instanceof Je && e2 instanceof Je ? Ot(t3.k, e2.k) : t3 instanceof je && e2 instanceof je;
  }(t2.transform, e.transform);
}
var en = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var nn = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new nn();
  }
  static exists(t2) {
    return new nn(void 0, t2);
  }
  static updateTime(t2) {
    return new nn(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function sn(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var rn = class {
};
function on(t2, e, n) {
  t2 instanceof ln ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = _n(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof fn ? function(t3, e2, n2) {
    if (!sn(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = _n(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(dn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function cn(t2, e, n) {
  t2 instanceof ln ? function(t3, e2, n2) {
    if (!sn(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = wn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(hn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof fn ? function(t3, e2, n2) {
    if (!sn(t3.precondition, e2))
      return;
    const s = wn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(dn(t3)), i.setAll(s), e2.convertToFoundDocument(hn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    sn(t3.precondition, e2) && e2.convertToNoDocument(at.min());
  }(t2, e);
}
function un(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Ge(s.transform, t3 || null);
    i != null && (n == null && (n = zt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function an(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && ot(t3, e2, (t4, e3) => tn(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function hn(t2) {
  return t2.isFoundDocument() ? t2.version : at.min();
}
var ln = class extends rn {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var fn = class extends rn {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function dn(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function _n(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  U2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, c = e.data.field(r.field);
    s.set(r.field, Ke(o, c, n[i]));
  }
  return s;
}
function wn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, qe(t3, r, e));
  }
  return s;
}
var mn = class extends rn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var gn = class extends rn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var yn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var pn;
var In;
function En(t2) {
  switch (t2) {
    default:
      return L2();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function Tn(t2) {
  if (t2 === void 0)
    return $("GRPC error has no .code"), G.UNKNOWN;
  switch (t2) {
    case pn.OK:
      return G.OK;
    case pn.CANCELLED:
      return G.CANCELLED;
    case pn.UNKNOWN:
      return G.UNKNOWN;
    case pn.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case pn.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case pn.INTERNAL:
      return G.INTERNAL;
    case pn.UNAVAILABLE:
      return G.UNAVAILABLE;
    case pn.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case pn.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case pn.NOT_FOUND:
      return G.NOT_FOUND;
    case pn.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case pn.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case pn.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case pn.ABORTED:
      return G.ABORTED;
    case pn.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case pn.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case pn.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L2();
  }
}
(In = pn || (pn = {}))[In.OK = 0] = "OK", In[In.CANCELLED = 1] = "CANCELLED", In[In.UNKNOWN = 2] = "UNKNOWN", In[In.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", In[In.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", In[In.NOT_FOUND = 5] = "NOT_FOUND", In[In.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", In[In.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", In[In.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", In[In.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", In[In.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", In[In.ABORTED = 10] = "ABORTED", In[In.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", In[In.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", In[In.INTERNAL = 13] = "INTERNAL", In[In.UNAVAILABLE = 14] = "UNAVAILABLE", In[In.DATA_LOSS = 15] = "DATA_LOSS";
var An = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Pn.EMPTY;
  }
  insert(t2, e) {
    return new An(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Pn.BLACK, null, null));
  }
  remove(t2) {
    return new An(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Pn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Rn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Rn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Rn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Rn(this.root, t2, this.comparator, true);
  }
};
var Rn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Pn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Pn.RED, this.left = s != null ? s : Pn.EMPTY, this.right = i != null ? i : Pn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Pn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Pn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Pn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Pn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Pn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Pn.EMPTY = null, Pn.RED = true, Pn.BLACK = false;
Pn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Pn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var bn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new An(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new vn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new vn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof bn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new bn(this.comparator);
    return e.data = t2, e;
  }
};
var vn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Vn(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var Sn = new An(Nt.comparator);
function Dn() {
  return Sn;
}
var Cn = new An(Nt.comparator);
function Nn() {
  return Cn;
}
var xn = new An(Nt.comparator);
var kn = new bn(Nt.comparator);
function On(...t2) {
  let e = kn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Mn = new bn(rt);
function $n() {
  return Mn;
}
var Fn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, Bn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Fn(at.min(), n, $n(), Dn(), On());
  }
};
var Bn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new Bn(pt.EMPTY_BYTE_STRING, e, On(), On(), On());
  }
};
var Ln = class {
  constructor(t2, e, n, s) {
    this.M = t2, this.removedTargetIds = e, this.key = n, this.$ = s;
  }
};
var Un = class {
  constructor(t2, e) {
    this.targetId = t2, this.F = e;
  }
};
var qn = class {
  constructor(t2, e, n = pt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var Kn = class {
  constructor() {
    this.B = 0, this.L = Qn(), this.U = pt.EMPTY_BYTE_STRING, this.q = false, this.K = true;
  }
  get current() {
    return this.q;
  }
  get resumeToken() {
    return this.U;
  }
  get G() {
    return this.B !== 0;
  }
  get j() {
    return this.K;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.K = true, this.U = t2);
  }
  H() {
    let t2 = On(), e = On(), n = On();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new Bn(this.U, this.q, t2, e, n);
  }
  J() {
    this.K = false, this.L = Qn();
  }
  Y(t2, e) {
    this.K = true, this.L = this.L.insert(t2, e);
  }
  X(t2) {
    this.K = true, this.L = this.L.remove(t2);
  }
  Z() {
    this.B += 1;
  }
  tt() {
    this.B -= 1;
  }
  et() {
    this.K = true, this.q = true;
  }
};
var Gn = class {
  constructor(t2) {
    this.nt = t2, this.st = /* @__PURE__ */ new Map(), this.it = Dn(), this.rt = jn(), this.ot = new bn(rt);
  }
  ct(t2) {
    for (const e of t2.M)
      t2.$ && t2.$.isFoundDocument() ? this.ut(e, t2.$) : this.at(e, t2.key, t2.$);
    for (const e of t2.removedTargetIds)
      this.at(e, t2.key, t2.$);
  }
  ht(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.lt(e);
      switch (t2.state) {
        case 0:
          this.ft(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.tt(), n.G || n.J(), n.W(t2.resumeToken);
          break;
        case 2:
          n.tt(), n.G || this.removeTarget(e);
          break;
        case 3:
          this.ft(e) && (n.et(), n.W(t2.resumeToken));
          break;
        case 4:
          this.ft(e) && (this.dt(e), n.W(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.st.forEach((t3, n) => {
      this.ft(n) && e(n);
    });
  }
  _t(t2) {
    const e = t2.targetId, n = t2.F.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (oe(t3))
        if (n === 0) {
          const n2 = new Nt(t3.path);
          this.at(e, n2, Jt.newNoDocument(n2, at.min()));
        } else
          U2(n === 1);
      else {
        this.gt(e) !== n && (this.dt(e), this.ot = this.ot.add(e));
      }
    }
  }
  yt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.st.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && oe(i.target)) {
          const e2 = new Nt(i.target.path);
          this.it.get(e2) !== null || this.It(s2, e2) || this.at(s2, e2, Jt.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.H()), n2.J());
      }
    });
    let n = On();
    this.rt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.it.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new Fn(t2, e, this.ot, this.it, n);
    return this.it = Dn(), this.rt = jn(), this.ot = new bn(rt), s;
  }
  ut(t2, e) {
    if (!this.ft(t2))
      return;
    const n = this.It(t2, e.key) ? 2 : 0;
    this.lt(t2).Y(e.key, n), this.it = this.it.insert(e.key, e), this.rt = this.rt.insert(e.key, this.Et(e.key).add(t2));
  }
  at(t2, e, n) {
    if (!this.ft(t2))
      return;
    const s = this.lt(t2);
    this.It(t2, e) ? s.Y(e, 1) : s.X(e), this.rt = this.rt.insert(e, this.Et(e).delete(t2)), n && (this.it = this.it.insert(e, n));
  }
  removeTarget(t2) {
    this.st.delete(t2);
  }
  gt(t2) {
    const e = this.lt(t2).H();
    return this.nt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Z(t2) {
    this.lt(t2).Z();
  }
  lt(t2) {
    let e = this.st.get(t2);
    return e || (e = new Kn(), this.st.set(t2, e)), e;
  }
  Et(t2) {
    let e = this.rt.get(t2);
    return e || (e = new bn(rt), this.rt = this.rt.insert(t2, e)), e;
  }
  ft(t2) {
    const e = this.wt(t2) !== null;
    return e || M2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.st.get(t2);
    return e && e.G ? null : this.nt.Tt(t2);
  }
  dt(t2) {
    this.st.set(t2, new Kn());
    this.nt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.at(t2, e, null);
    });
  }
  It(t2, e) {
    return this.nt.getRemoteKeysForTarget(t2).has(e);
  }
};
function jn() {
  return new An(Nt.comparator);
}
function Qn() {
  return new An(Nt.comparator);
}
var Wn = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var zn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Hn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.N = e;
  }
};
function Jn(t2, e) {
  if (t2.N) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Yn(t2, e) {
  return t2.N ? e.toBase64() : e.toUint8Array();
}
function Xn(t2, e) {
  return Jn(t2, e.toTimestamp());
}
function Zn(t2) {
  return U2(!!t2), at.fromTimestamp(function(t3) {
    const e = Et(t3);
    return new ut(e.seconds, e.nanos);
  }(t2));
}
function ts(t2, e) {
  return function(t3) {
    return new _t(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function es(t2) {
  const e = _t.fromString(t2);
  return U2(vs(e)), e;
}
function ns(t2, e) {
  return ts(t2.databaseId, e.path);
}
function ss(t2, e) {
  const n = es(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new j(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new j(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Nt(cs(n));
}
function is(t2, e) {
  return ts(t2.databaseId, e);
}
function rs(t2) {
  const e = es(t2);
  return e.length === 4 ? _t.emptyPath() : cs(e);
}
function os(t2) {
  return new _t(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function cs(t2) {
  return U2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function us(t2, e, n) {
  return {
    name: ns(t2, e),
    fields: n.value.mapValue.fields
  };
}
function as(t2, e, n) {
  const s = ss(t2, e.name), i = Zn(e.updateTime), r = new zt({
    mapValue: {
      fields: e.fields
    }
  }), o = Jt.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function hs(t2, e) {
  return "found" in e ? function(t3, e2) {
    U2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = ss(t3, e2.found.name), s = Zn(e2.found.updateTime), i = new zt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Jt.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    U2(!!e2.missing), U2(!!e2.readTime);
    const n = ss(t3, e2.missing), s = Zn(e2.readTime);
    return Jt.newNoDocument(n, s);
  }(t2, e) : L2();
}
function ls(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.N ? (U2(e2 === void 0 || typeof e2 == "string"), pt.fromBase64String(e2 || "")) : (U2(e2 === void 0 || e2 instanceof Uint8Array), pt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, c = o && function(t3) {
      const e2 = t3.code === void 0 ? G.UNKNOWN : Tn(t3.code);
      return new j(e2, t3.message || "");
    }(o);
    n = new qn(s, i, r, c || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = ss(t2, s.document.name), r = Zn(s.document.updateTime), o = new zt({
      mapValue: {
        fields: s.document.fields
      }
    }), c = Jt.newFoundDocument(i, r, o), u = s.targetIds || [], a = s.removedTargetIds || [];
    n = new Ln(u, a, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = ss(t2, s.document), r = s.readTime ? Zn(s.readTime) : at.min(), o = Jt.newNoDocument(i, r), c = s.removedTargetIds || [];
    n = new Ln([], c, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = ss(t2, s.document), r = s.removedTargetIds || [];
    n = new Ln([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new yn(s), r = t3.targetId;
      n = new Un(r, i);
    }
  }
  return n;
}
function fs(t2, e) {
  let n;
  if (e instanceof ln)
    n = {
      update: us(t2, e.key, e.value)
    };
  else if (e instanceof mn)
    n = {
      delete: ns(t2, e.key)
    };
  else if (e instanceof fn)
    n = {
      update: us(t2, e.key, e.data),
      updateMask: bs(e.fieldMask)
    };
  else {
    if (!(e instanceof gn))
      return L2();
    n = {
      verify: ns(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof je)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Qe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof ze)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Je)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.k
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Xn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function ds(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? nn.updateTime(Zn(t3.updateTime)) : t3.exists !== void 0 ? nn.exists(t3.exists) : nn.none();
  }(e.currentDocument) : nn.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U2(e3.setToServerValue === "REQUEST_TIME"), n2 = new je();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Qe(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new ze(t4);
    } else
      "increment" in e3 ? n2 = new Je(t3, e3.increment) : L2();
    const s2 = mt.fromServerFormat(e3.fieldPath);
    return new Ze(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = ss(t2, e.update.name), r = new zt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new gt(e2.map((t5) => mt.fromServerFormat(t5)));
      }(e.updateMask);
      return new fn(i, r, t3, n, s);
    }
    return new ln(i, r, n, s);
  }
  if (e.delete) {
    const s2 = ss(t2, e.delete);
    return new mn(s2, n);
  }
  if (e.verify) {
    const s2 = ss(t2, e.verify);
    return new gn(s2, n);
  }
  return L2();
}
function _s(t2, e) {
  return t2 && t2.length > 0 ? (U2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Zn(t4.updateTime) : Zn(e2);
    return n.isEqual(at.min()) && (n = Zn(e2)), new en(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function ws(t2, e) {
  return {
    documents: [is(t2, e.path)]
  };
}
function ms(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = is(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = is(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Ts(t5.field),
              op: "IS_NAN"
            }
          };
        if (Gt(t5.value))
          return {
            unaryFilter: {
              field: Ts(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Ts(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Gt(t5.value))
          return {
            unaryFilter: {
              field: Ts(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Ts(t5.field),
          op: Es(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Ts(t5.field),
        direction: Is(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.N || St(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var c;
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (c = e.startAt).inclusive,
    values: c.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function gs(t2) {
  let e = rs(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = ps(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new ge(As(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let c = null;
  n.limit && (c = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, St(e2) ? null : e2;
  }(n.limit));
  let u = null;
  n.startAt && (u = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new me(n2, e2);
  }(n.startAt));
  let a = null;
  return n.endAt && (a = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new me(n2, e2);
  }(n.endAt)), Te(e, i, o, r, c, "F", u, a);
}
function ys(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function ps(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [Ps(t2)] : t2.fieldFilter !== void 0 ? [Rs(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => ps(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function Is(t2) {
  return Wn[t2];
}
function Es(t2) {
  return zn[t2];
}
function Ts(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function As(t2) {
  return mt.fromServerFormat(t2.fieldPath);
}
function Rs(t2) {
  return ce.create(As(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function Ps(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = As(t2.unaryFilter.field);
      return ce.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = As(t2.unaryFilter.field);
      return ce.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = As(t2.unaryFilter.field);
      return ce.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = As(t2.unaryFilter.field);
      return ce.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function bs(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function vs(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Vs(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Ds(e)), e = Ss(t2.get(n), e);
  return Ds(e);
}
function Ss(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Ds(t2) {
  return t2 + "";
}
function Cs(t2) {
  const e = t2.length;
  if (U2(e >= 2), e === 2)
    return U2(t2.charAt(0) === "" && t2.charAt(1) === ""), _t.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new _t(s);
}
var Ns = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var xs = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
xs.store = "owner", xs.key = "owner";
var ks = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
ks.store = "mutationQueues", ks.keyPath = "userId";
var Os = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
Os.store = "mutations", Os.keyPath = "batchId", Os.userMutationsIndex = "userMutationsIndex", Os.userMutationsKeyPath = ["userId", "batchId"];
var Ms = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, Vs(e)];
  }
  static key(t2, e, n) {
    return [t2, Vs(e), n];
  }
};
Ms.store = "documentMutations", Ms.PLACEHOLDER = new Ms();
var $s = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var Fs = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Bs = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Bs.store = "remoteDocuments", Bs.readTimeIndex = "readTimeIndex", Bs.readTimeIndexPath = "readTime", Bs.collectionReadTimeIndex = "collectionReadTimeIndex", Bs.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Ls = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Ls.store = "remoteDocumentGlobal", Ls.key = "remoteDocumentGlobalKey";
var Us = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
Us.store = "targets", Us.keyPath = "targetId", Us.queryTargetsIndexName = "queryTargetsIndex", Us.queryTargetsKeyPath = ["canonicalId", "targetId"];
var qs = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
qs.store = "targetDocuments", qs.keyPath = ["targetId", "path"], qs.documentTargetsIndex = "documentTargetsIndex", qs.documentTargetsKeyPath = ["path", "targetId"];
var Ks = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
Ks.key = "targetGlobalKey", Ks.store = "targetGlobal";
var Gs = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Gs.store = "collectionParents", Gs.keyPath = ["collectionId", "parent"];
var js = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
js.store = "clientMetadata", js.keyPath = "clientId";
var Qs = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
Qs.store = "bundles", Qs.keyPath = "bundleId";
var Ws = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Ws.store = "namedQueries", Ws.keyPath = "name";
var zs = class {
  constructor(t2, e, n) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n;
  }
};
zs.store = "indexConfiguration", zs.keyPath = "indexId", zs.collectionGroupIndex = "collectionGroupIndex", zs.collectionGroupIndexPath = "collectionGroup";
var Hs = class {
  constructor(t2, e, n, s, i, r) {
    this.indexId = t2, this.uid = e, this.sequenceNumber = n, this.readTime = s, this.documentKey = i, this.largestBatchId = r;
  }
};
Hs.store = "indexState", Hs.keyPath = ["indexId", "uid"], Hs.sequenceNumberIndex = "sequenceNumberIndex", Hs.sequenceNumberIndexPath = ["uid", "sequenceNumber"];
var Js = class {
  constructor(t2, e, n, s, i) {
    this.indexId = t2, this.uid = e, this.arrayValue = n, this.directionalValue = s, this.documentKey = i;
  }
};
Js.store = "indexEntries", Js.keyPath = ["indexId", "uid", "arrayValue", "directionalValue", "documentKey"], Js.documentKeyIndex = "documentKeyIndex", Js.documentKeyIndexPath = ["indexId", "uid", "documentKey"];
var Ys = class {
  constructor(t2, e, n, s, i, r) {
    this.userId = t2, this.collectionPath = e, this.documentId = n, this.collectionGroup = s, this.largestBatchId = i, this.overlayMutation = r;
  }
};
Ys.store = "documentOverlays", Ys.keyPath = ["userId", "collectionPath", "documentId"], Ys.collectionPathOverlayIndex = "collectionPathOverlayIndex", Ys.collectionPathOverlayIndexPath = ["userId", "collectionPath", "largestBatchId"], Ys.collectionGroupOverlayIndex = "collectionGroupOverlayIndex", Ys.collectionGroupOverlayIndexPath = ["userId", "collectionGroup", "largestBatchId"];
var Xs = [...[...[...[...[ks.store, Os.store, Ms.store, Bs.store, Us.store, xs.store, Ks.store, qs.store], js.store], Ls.store], Gs.store], Qs.store, Ws.store];
var Zs = [...Xs, Ys.store];
var ti = [...Zs, zs.store, Hs.store, Js.store];
var ei = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var ni = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var si = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new si((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof si ? e : si.resolve(e);
    } catch (t3) {
      return si.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : si.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : si.reject(e);
  }
  static resolve(t2) {
    return new si((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new si((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new si((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = si.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? si.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var ii = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.At = new Q2(), this.transaction.oncomplete = () => {
      this.At.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.At.reject(new ci(t2, e.error)) : this.At.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = fi(e2.target.error);
      this.At.reject(new ci(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new ii(e, t2.transaction(s, n));
    } catch (t3) {
      throw new ci(e, t3);
    }
  }
  get Rt() {
    return this.At.promise;
  }
  abort(t2) {
    t2 && this.At.reject(t2), this.aborted || (M2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  Pt() {
    const t2 = this.transaction;
    this.aborted || typeof t2.commit != "function" || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new ai(e);
  }
};
var ri = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.bt = n;
    ri.vt(getUA()) === 12.2 && $("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return M2("SimpleDb", "Removing database:", t2), hi(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static Vt() {
    if (!isIndexedDBAvailable())
      return false;
    if (ri.St())
      return true;
    const t2 = getUA(), e = ri.vt(t2), n = 0 < e && e < 10, s = ri.Dt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static St() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Ct) === "YES";
  }
  static Nt(t2, e) {
    return t2.store(e);
  }
  static vt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Dt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async xt(t2) {
    return this.db || (M2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new ci(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new j(G.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new j(G.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new ci(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        M2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.bt.kt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          M2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Ot && (this.db.onversionchange = (t3) => this.Ot(t3)), this.db;
  }
  Mt(t2) {
    this.Ot = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.xt(t2);
        const e2 = ii.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.Pt(), t3)).catch((t3) => (e2.abort(t3), si.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.Rt, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (M2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var oi = class {
  constructor(t2) {
    this.$t = t2, this.Ft = false, this.Bt = null;
  }
  get isDone() {
    return this.Ft;
  }
  get Lt() {
    return this.Bt;
  }
  set cursor(t2) {
    this.$t = t2;
  }
  done() {
    this.Ft = true;
  }
  Ut(t2) {
    this.Bt = t2;
  }
  delete() {
    return hi(this.$t.delete());
  }
};
var ci = class extends j {
  constructor(t2, e) {
    super(G.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function ui(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var ai = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (M2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (M2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), hi(n);
  }
  add(t2) {
    M2("SimpleDb", "ADD", this.store.name, t2, t2);
    return hi(this.store.add(t2));
  }
  get(t2) {
    return hi(this.store.get(t2)).next((e) => (e === void 0 && (e = null), M2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    M2("SimpleDb", "DELETE", this.store.name, t2);
    return hi(this.store.delete(t2));
  }
  count() {
    M2("SimpleDb", "COUNT", this.store.name);
    return hi(this.store.count());
  }
  qt(t2, e) {
    const n = this.options(t2, e);
    if (n.index || typeof this.store.getAll != "function") {
      const t3 = this.cursor(n), e2 = [];
      return this.Kt(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new si((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  Gt(t2, e) {
    M2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.jt = false;
    const s = this.cursor(n);
    return this.Kt(s, (t3, e2, n2) => n2.delete());
  }
  Qt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Kt(s, e);
  }
  Wt(t2) {
    const e = this.cursor({});
    return new si((n, s) => {
      e.onerror = (t3) => {
        const e2 = fi(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Kt(t2, e) {
    const n = [];
    return new si((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new oi(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof si) {
          const t4 = o.catch((t5) => (r.done(), si.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Lt === null ? i2.continue() : i2.continue(r.Lt);
      };
    }).next(() => si.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.jt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function hi(t2) {
  return new si((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = fi(t3.target.error);
      n(e2);
    };
  });
}
var li = false;
function fi(t2) {
  const e = ri.vt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new j("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return li || (li = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var di = class extends ni {
  constructor(t2, e) {
    super(), this.zt = t2, this.currentSequenceNumber = e;
  }
};
function _i(t2, e) {
  const n = K2(t2);
  return ri.Nt(n.zt, e);
}
var wi = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        on(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && cn(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && cn(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(at.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), On());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && ot(this.mutations, t2.mutations, (t3, e) => an(t3, e)) && ot(this.baseMutations, t2.baseMutations, (t3, e) => an(t3, e));
  }
};
var mi = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    U2(t2.mutations.length === n.length);
    let s = xn;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new mi(t2, e, n, s);
  }
};
var gi = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return t2 !== null && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var yi = class {
  constructor(t2, e, n, s, i = at.min(), r = at.min(), o = pt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new yi(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new yi(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new yi(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var pi = class {
  constructor(t2) {
    this.Ht = t2;
  }
};
function Ii(t2, e) {
  let n;
  if (e.document)
    n = as(t2.Ht, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = Nt.fromSegments(e.noDocument.path), s = Pi(e.noDocument.readTime);
    n = Jt.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L2();
    {
      const t3 = Nt.fromSegments(e.unknownDocument.path), s = Pi(e.unknownDocument.version);
      n = Jt.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(Ai(e.readTime)), n;
}
function Ei(t2, e) {
  const n = Ti(e.readTime), s = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const i = function(t3, e2) {
      return {
        name: ns(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Jn(t3, e2.version.toTimestamp())
      };
    }(t2.Ht, e), r = e.hasCommittedMutations;
    return new Bs(null, null, i, r, n, s);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), i = Ri(e.version), r = e.hasCommittedMutations;
    return new Bs(null, new $s(t3, i), null, r, n, s);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), i = Ri(e.version);
    return new Bs(new Fs(t3, i), null, null, true, n, s);
  }
  return L2();
}
function Ti(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Ai(t2) {
  const e = new ut(t2[0], t2[1]);
  return at.fromTimestamp(e);
}
function Ri(t2) {
  const e = t2.toTimestamp();
  return new Ns(e.seconds, e.nanoseconds);
}
function Pi(t2) {
  const e = new ut(t2.seconds, t2.nanoseconds);
  return at.fromTimestamp(e);
}
function bi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => ds(t2.Ht, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => ds(t2.Ht, e2)), i = ut.fromMillis(e.localWriteTimeMs);
  return new wi(e.batchId, i, n, s);
}
function vi(t2) {
  const e = Pi(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? Pi(t2.lastLimboFreeSnapshotVersion) : at.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (U2((i = t2.query).documents.length === 1), s = De(Ae(rs(i.documents[0])))) : s = function(t3) {
    return De(gs(t3));
  }(t2.query), new yi(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, pt.fromBase64String(t2.resumeToken));
}
function Vi(t2, e) {
  const n = Ri(e.snapshotVersion), s = Ri(e.lastLimboFreeSnapshotVersion);
  let i;
  i = oe(e.target) ? ws(t2.Ht, e.target) : ms(t2.Ht, e.target);
  const r = e.resumeToken.toBase64();
  return new Us(e.targetId, se(e.target), n, r, e.sequenceNumber, s, i);
}
function Si(t2) {
  const e = gs({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Ce(e, e.limit, "L") : e;
}
function Di(t2, e) {
  return new gi(e.largestBatchId, ds(t2.Ht, e.overlayMutation));
}
function Ci(t2, e) {
  const n = e.path.lastSegment();
  return [t2, Vs(e.path.popLast()), n];
}
var Ni = class {
  getBundleMetadata(t2, e) {
    return xi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: Pi(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return xi(t2).put({
      bundleId: (n = e).id,
      createTime: Ri(Zn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return ki(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: Si(e2.bundledQuery),
          readTime: Pi(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return ki(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Ri(Zn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function xi(t2) {
  return _i(t2, Qs.store);
}
function ki(t2) {
  return _i(t2, Ws.store);
}
var Oi = class {
  constructor(t2, e) {
    this.O = t2, this.userId = e;
  }
  static Jt(t2, e) {
    const n = e.uid || "";
    return new Oi(t2, n);
  }
  getOverlay(t2, e) {
    return Mi(t2).get(Ci(this.userId, e)).next((t3) => t3 ? Di(this.O, t3) : null);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2) => {
      const i = new gi(e, n2);
      s.push(this.Yt(t2, i));
    }), si.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(Vs(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(Mi(t2).Gt(Ys.collectionPathOverlayIndex, s2));
    }), si.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = /* @__PURE__ */ new Map(), i = Vs(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return Mi(t2).qt(Ys.collectionPathOverlayIndex, r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Di(this.O, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = /* @__PURE__ */ new Map();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return Mi(t2).Qt({
      index: Ys.collectionGroupOverlayIndex,
      range: o
    }, (t3, e2, n2) => {
      const o2 = Di(this.O, e2);
      i.size < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  Yt(t2, e) {
    return Mi(t2).put(function(t3, e2, n) {
      const [s, i, r] = Ci(e2, n.mutation.key);
      return new Ys(e2, i, r, n.mutation.key.getCollectionGroup(), n.largestBatchId, fs(t3.Ht, n.mutation));
    }(this.O, this.userId, e));
  }
};
function Mi(t2) {
  return _i(t2, Ys.store);
}
var $i = class {
  constructor() {
  }
  Xt(t2, e) {
    this.Zt(t2, e), e.te();
  }
  Zt(t2, e) {
    if ("nullValue" in t2)
      this.ee(e, 5);
    else if ("booleanValue" in t2)
      this.ee(e, 10), e.ne(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ee(e, 15), e.ne(Tt(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Tt(t2.doubleValue);
      isNaN(n) ? this.ee(e, 13) : (this.ee(e, 15), Dt(n) ? e.ne(0) : e.ne(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ee(e, 20), typeof n == "string" ? e.se(n) : (e.se(`${n.seconds || ""}`), e.ne(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.ie(t2.stringValue, e), this.re(e);
    else if ("bytesValue" in t2)
      this.ee(e, 30), e.oe(At(t2.bytesValue)), this.re(e);
    else if ("referenceValue" in t2)
      this.ce(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ee(e, 45), e.ne(n.latitude || 0), e.ne(n.longitude || 0);
    } else
      "mapValue" in t2 ? Ot(t2, xt) ? this.ee(e, Number.MAX_SAFE_INTEGER) : (this.ue(t2.mapValue, e), this.re(e)) : "arrayValue" in t2 ? (this.ae(t2.arrayValue, e), this.re(e)) : L2();
  }
  ie(t2, e) {
    this.ee(e, 25), this.he(t2, e);
  }
  he(t2, e) {
    e.se(t2);
  }
  ue(t2, e) {
    const n = t2.fields || {};
    this.ee(e, 55);
    for (const t3 of Object.keys(n))
      this.ie(t3, e), this.Zt(n[t3], e);
  }
  ae(t2, e) {
    const n = t2.values || [];
    this.ee(e, 50);
    for (const t3 of n)
      this.Zt(t3, e);
  }
  ce(t2, e) {
    this.ee(e, 37);
    Nt.fromName(t2).path.forEach((t3) => {
      this.ee(e, 60), this.he(t3, e);
    });
  }
  ee(t2, e) {
    t2.ne(e);
  }
  re(t2) {
    t2.ne(2);
  }
};
$i.le = new $i();
function Fi(t2) {
  if (t2 === 0)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function Bi(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = Fi(255 & t3[n]);
      if (e2 += s, s !== 8)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var Li = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  fe(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.de(n.value), n = e.next();
    this._e();
  }
  we(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.me(n.value), n = e.next();
    this.ge();
  }
  ye(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.de(t3);
      else if (t3 < 2048)
        this.de(960 | t3 >>> 6), this.de(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.de(480 | t3 >>> 12), this.de(128 | 63 & t3 >>> 6), this.de(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.de(240 | t4 >>> 18), this.de(128 | 63 & t4 >>> 12), this.de(128 | 63 & t4 >>> 6), this.de(128 | 63 & t4);
      }
    }
    this._e();
  }
  pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.me(t3);
      else if (t3 < 2048)
        this.me(960 | t3 >>> 6), this.me(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.me(480 | t3 >>> 12), this.me(128 | 63 & t3 >>> 6), this.me(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.me(240 | t4 >>> 18), this.me(128 | 63 & t4 >>> 12), this.me(128 | 63 & t4 >>> 6), this.me(128 | 63 & t4);
      }
    }
    this.ge();
  }
  Ie(t2) {
    const e = this.Ee(t2), n = Bi(e);
    this.Te(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Ae(t2) {
    const e = this.Ee(t2), n = Bi(e);
    this.Te(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  Re() {
    this.Pe(255), this.Pe(255);
  }
  be() {
    this.ve(255), this.ve(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.Te(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  Ve() {
    return this.buffer.slice(0, this.position);
  }
  Ee(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = (128 & e[0]) != 0;
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  de(t2) {
    const e = 255 & t2;
    e === 0 ? (this.Pe(0), this.Pe(255)) : e === 255 ? (this.Pe(255), this.Pe(0)) : this.Pe(e);
  }
  me(t2) {
    const e = 255 & t2;
    e === 0 ? (this.ve(0), this.ve(255)) : e === 255 ? (this.ve(255), this.ve(0)) : this.ve(t2);
  }
  _e() {
    this.Pe(0), this.Pe(1);
  }
  ge() {
    this.ve(0), this.ve(1);
  }
  Pe(t2) {
    this.Te(1), this.buffer[this.position++] = t2;
  }
  ve(t2) {
    this.Te(1), this.buffer[this.position++] = ~t2;
  }
  Te(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var Ui = class {
  constructor(t2) {
    this.Se = t2;
  }
  oe(t2) {
    this.Se.fe(t2);
  }
  se(t2) {
    this.Se.ye(t2);
  }
  ne(t2) {
    this.Se.Ie(t2);
  }
  te() {
    this.Se.Re();
  }
};
var qi = class {
  constructor(t2) {
    this.Se = t2;
  }
  oe(t2) {
    this.Se.we(t2);
  }
  se(t2) {
    this.Se.pe(t2);
  }
  ne(t2) {
    this.Se.Ae(t2);
  }
  te() {
    this.Se.be();
  }
};
var Ki = class {
  constructor() {
    this.Se = new Li(), this.De = new Ui(this.Se), this.Ce = new qi(this.Se);
  }
  seed(t2) {
    this.Se.seed(t2);
  }
  Ne(t2) {
    return t2 === 0 ? this.De : this.Ce;
  }
  Ve() {
    return this.Se.Ve();
  }
  reset() {
    this.Se.reset();
  }
};
var Gi = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
};
function ji(t2, e) {
  let n = t2.indexId - e.indexId;
  return n !== 0 ? n : (n = Nt.comparator(t2.documentKey, e.documentKey), n !== 0 ? n : (n = Qi(t2.arrayValue, e.arrayValue), n !== 0 ? n : Qi(t2.directionalValue, e.directionalValue)));
}
function Qi(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (s !== 0)
      return s;
  }
  return t2.length - e.length;
}
var Wi = class {
  constructor() {
    this.xe = new zi();
  }
  addToCollectionParentIndex(t2, e) {
    return this.xe.add(e), si.resolve();
  }
  getCollectionParents(t2, e) {
    return si.resolve(this.xe.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return si.resolve();
  }
  deleteFieldIndex(t2, e) {
    return si.resolve();
  }
  getDocumentsMatchingTarget(t2, e, n) {
    return si.resolve(On());
  }
  getFieldIndex(t2, e) {
    return si.resolve(null);
  }
  getFieldIndexes(t2, e) {
    return si.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return si.resolve(null);
  }
  updateCollectionGroup(t2, e, n) {
    return si.resolve();
  }
  updateIndexEntries(t2, e) {
    return si.resolve();
  }
};
var zi = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new bn(_t.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new bn(_t.comparator)).toArray();
  }
};
var Hi = class {
  constructor(t2) {
    this.user = t2, this.ke = new zi(), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.ke.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.ke.add(e);
      });
      const i = {
        collectionId: n,
        parent: Vs(s)
      };
      return Ji(t2).put(i);
    }
    return si.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ct(e), ""], false, true);
    return Ji(t2).qt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Cs(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = Xi(t2), s = function(t3) {
      return new zs(t3.indexId, t3.collectionGroup, t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind]));
    }(e);
    return delete s.indexId, n.add(s).next();
  }
  deleteFieldIndex(t2, e) {
    const n = Xi(t2), s = Zi(t2), i = Yi(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t2, e, n) {
    return si.resolve(On());
  }
  getFieldIndex(t2, e) {
    return si.resolve(null);
  }
  Oe(t2, e) {
    const n = new Ki();
    for (const s of function(t3) {
      return t3.fields.filter((t4) => t4.kind !== 2);
    }(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (t3 == null)
        return null;
      const i = n.Ne(s.kind);
      $i.le.Xt(t3, i);
    }
    return n.Ve();
  }
  Me(t2) {
    const e = new Ki();
    return $i.le.Xt(t2, e.Ne(0)), e.Ve();
  }
  getFieldIndexes(t2, e) {
    const n = Xi(t2), s = Zi(t2);
    return (e ? n.qt(zs.collectionGroupIndex, IDBKeyRange.bound(e, e)) : n.qt()).next((t3) => {
      const e2 = [];
      return si.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new Zt(e3.sequenceNumber, new te(Pi(e3.readTime), new Nt(Cs(e3.documentKey)), e3.largestBatchId)) : Zt.empty(), s2 = t5.fields.map(([t6, e4]) => new Xt(mt.fromServerFormat(t6), e4));
          return new Yt(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => t3.length === 0 ? null : (t3.sort((t4, e) => t4.indexState.sequenceNumber - e.indexState.sequenceNumber), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = Xi(t2), i = Zi(t2);
    return this.$e(t2).next((t3) => s.qt(zs.collectionGroupIndex, IDBKeyRange.bound(e, e)).next((e2) => si.forEach(e2, (e3) => i.put(function(t4, e4, n2, s2) {
      return new Hs(t4, e4.uid || "", n2, Ri(s2.readTime), Vs(s2.documentKey.path), s2.largestBatchId);
    }(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return si.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? si.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), si.forEach(i2, (n2) => this.Fe(t2, e2, n2).next((e3) => {
        const i3 = this.Be(s, n2);
        return e3.isEqual(i3) ? si.resolve() : this.Le(t2, s, e3, i3);
      }))));
    });
  }
  Ue(t2, e, n) {
    return Yi(t2).put(new Js(n.indexId, this.uid, n.arrayValue, n.directionalValue, Vs(e.key.path)));
  }
  qe(t2, e, n) {
    return Yi(t2).delete([n.indexId, this.uid, n.arrayValue, n.directionalValue, Vs(e.key.path)]);
  }
  Fe(t2, e, n) {
    const s = Yi(t2);
    let i = new bn(ji);
    return s.Qt({
      index: Js.documentKeyIndex,
      range: IDBKeyRange.only([n.indexId, this.uid, Vs(e.path)])
    }, (t3, s2) => {
      i = i.add(new Gi(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  Be(t2, e) {
    let n = new bn(ji);
    const s = this.Oe(e, t2);
    if (s == null)
      return n;
    const i = function(t3) {
      return t3.fields.find((t4) => t4.kind === 2);
    }(e);
    if (i != null) {
      const r = t2.data.field(i.fieldPath);
      if (Kt(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new Gi(e.indexId, t2.key, this.Me(i2), s));
    } else
      n = n.add(new Gi(e.indexId, t2.key, new Uint8Array(), s));
    return n;
  }
  Le(t2, e, n, s) {
    M2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const i = [];
    return function(t3, e2, n2, s2, i2) {
      const r = t3.getIterator(), o = e2.getIterator();
      let c = Vn(r), u = Vn(o);
      for (; c || u; ) {
        let t4 = false, e3 = false;
        if (c && u) {
          const s3 = n2(c, u);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          c != null ? e3 = true : t4 = true;
        t4 ? (s2(u), u = Vn(o)) : e3 ? (i2(c), c = Vn(r)) : (c = Vn(r), u = Vn(o));
      }
    }(n, s, ji, (n2) => {
      i.push(this.Ue(t2, e, n2));
    }, (n2) => {
      i.push(this.qe(t2, e, n2));
    }), si.waitFor(i);
  }
  $e(t2) {
    let e = 1;
    return Zi(t2).Qt({
      index: Hs.sequenceNumberIndex,
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
};
function Ji(t2) {
  return _i(t2, Gs.store);
}
function Yi(t2) {
  return _i(t2, Js.store);
}
function Xi(t2) {
  return _i(t2, zs.store);
}
function Zi(t2) {
  return _i(t2, Hs.store);
}
var tr = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var er = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new er(t2, er.DEFAULT_COLLECTION_PERCENTILE, er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function nr(t2, e, n) {
  const s = t2.store(Os.store), i = t2.store(Ms.store), r = [], o = IDBKeyRange.only(n.batchId);
  let c = 0;
  const u = s.Qt({
    range: o
  }, (t3, e2, n2) => (c++, n2.delete()));
  r.push(u.next(() => {
    U2(c === 1);
  }));
  const a = [];
  for (const t3 of n.mutations) {
    const s2 = Ms.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t3.key);
  }
  return si.waitFor(r).next(() => a);
}
function sr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
er.DEFAULT_COLLECTION_PERCENTILE = 10, er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, er.DEFAULT = new er(41943040, er.DEFAULT_COLLECTION_PERCENTILE, er.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), er.DISABLED = new er(-1, 0, 0);
var ir = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.O = e, this.indexManager = n, this.referenceDelegate = s, this.Ke = {};
  }
  static Jt(t2, e, n, s) {
    U2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new ir(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return or(t2).Qt({
      index: Os.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = cr(t2), r = or(t2);
    return r.add({}).next((o) => {
      U2(typeof o == "number");
      const c = new wi(o, e, n, s), u = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => fs(t3.Ht, e3)), i2 = n2.mutations.map((e3) => fs(t3.Ht, e3));
        return new Os(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.O, this.userId, c), a = [];
      let h = new bn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ms.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), a.push(r.put(u)), a.push(i.put(e2, Ms.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        a.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Ke[o] = c.keys();
      }), si.waitFor(a).next(() => c);
    });
  }
  lookupMutationBatch(t2, e) {
    return or(t2).get(e).next((t3) => t3 ? (U2(t3.userId === this.userId), bi(this.O, t3)) : null);
  }
  Ge(t2, e) {
    return this.Ke[e] ? si.resolve(this.Ke[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Ke[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return or(t2).Qt({
      index: Os.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (U2(e2.batchId >= n), i = bi(this.O, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return or(t2).Qt({
      index: Os.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return or(t2).qt(Os.userMutationsIndex, e).next((t3) => t3.map((t4) => bi(this.O, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Ms.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return cr(t2).Qt({
      range: s
    }, (n2, s2, r) => {
      const [o, c, u] = n2, a = Cs(c);
      if (o === this.userId && e.path.isEqual(a))
        return or(t2).get(u).next((t3) => {
          if (!t3)
            throw L2();
          U2(t3.userId === this.userId), i.push(bi(this.O, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new bn(rt);
    const s = [];
    return e.forEach((e2) => {
      const i = Ms.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = cr(t2).Qt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, c] = t3, u = Cs(o2);
        r2 === this.userId && e2.path.isEqual(u) ? n = n.add(c) : i2.done();
      });
      s.push(o);
    }), si.waitFor(s).next(() => this.je(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Ms.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new bn(rt);
    return cr(t2).Qt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, c, u] = t3, a = Cs(c);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(u)) : i2.done();
    }).next(() => this.je(t2, o));
  }
  je(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(or(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        U2(t3.userId === this.userId), n.push(bi(this.O, t3));
      }));
    }), si.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return nr(t2.zt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.Qe(e.batchId);
    }), si.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  Qe(t2) {
    delete this.Ke[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return si.resolve();
      const n = IDBKeyRange.lowerBound(Ms.prefixForUser(this.userId)), s = [];
      return cr(t2).Qt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Cs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return rr(t2, this.userId, e);
  }
  We(t2) {
    return ur(t2).get(this.userId).next((t3) => t3 || new ks(this.userId, -1, ""));
  }
};
function rr(t2, e, n) {
  const s = Ms.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return cr(t2).Qt({
    range: r,
    jt: true
  }, (t3, n2, s2) => {
    const [r2, c, u] = t3;
    r2 === e && c === i && (o = true), s2.done();
  }).next(() => o);
}
function or(t2) {
  return _i(t2, Os.store);
}
function cr(t2) {
  return _i(t2, Ms.store);
}
function ur(t2) {
  return _i(t2, ks.store);
}
var ar = class {
  constructor(t2) {
    this.ze = t2;
  }
  next() {
    return this.ze += 2, this.ze;
  }
  static He() {
    return new ar(0);
  }
  static Je() {
    return new ar(-1);
  }
};
var hr = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.O = e;
  }
  allocateTargetId(t2) {
    return this.Ye(t2).next((e) => {
      const n = new ar(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Xe(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.Ye(t2).next((t3) => at.fromTimestamp(new ut(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.Ye(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.Ye(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Xe(t2, s)));
  }
  addTargetData(t2, e) {
    return this.Ze(t2, e).next(() => this.Ye(t2).next((n) => (n.targetCount += 1, this.tn(e, n), this.Xe(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.Ze(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => lr(t2).delete(e.targetId)).next(() => this.Ye(t2)).next((e2) => (U2(e2.targetCount > 0), e2.targetCount -= 1, this.Xe(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return lr(t2).Qt((r, o) => {
      const c = vi(o);
      c.sequenceNumber <= e && n.get(c.targetId) === null && (s++, i.push(this.removeTargetData(t2, c)));
    }).next(() => si.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return lr(t2).Qt((t3, n) => {
      const s = vi(n);
      e(s);
    });
  }
  Ye(t2) {
    return fr(t2).get(Ks.key).next((t3) => (U2(t3 !== null), t3));
  }
  Xe(t2, e) {
    return fr(t2).put(Ks.key, e);
  }
  Ze(t2, e) {
    return lr(t2).put(Vi(this.O, e));
  }
  tn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.Ye(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = se(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return lr(t2).Qt({
      range: s,
      index: Us.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = vi(n2);
      re(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = dr(t2);
    return e.forEach((e2) => {
      const r = Vs(e2.path);
      s.push(i.put(new qs(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), si.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = dr(t2);
    return si.forEach(e, (e2) => {
      const i = Vs(e2.path);
      return si.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = dr(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = dr(t2);
    let i = On();
    return s.Qt({
      range: n,
      jt: true
    }, (t3, e2, n2) => {
      const s2 = Cs(t3[1]), r = new Nt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Vs(e.path), s = IDBKeyRange.bound([n], [ct(n)], false, true);
    let i = 0;
    return dr(t2).Qt({
      index: qs.documentTargetsIndex,
      jt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Tt(t2, e) {
    return lr(t2).get(e).next((t3) => t3 ? vi(t3) : null);
  }
};
function lr(t2) {
  return _i(t2, Us.store);
}
function fr(t2) {
  return _i(t2, Ks.store);
}
function dr(t2) {
  return _i(t2, qs.store);
}
async function _r(t2) {
  if (t2.code !== G.FAILED_PRECONDITION || t2.message !== ei)
    throw t2;
  M2("LocalStore", "Unexpectedly lost primary lease");
}
function wr([t2, e], [n, s]) {
  const i = rt(t2, n);
  return i === 0 ? rt(e, s) : i;
}
var mr = class {
  constructor(t2) {
    this.en = t2, this.buffer = new bn(wr), this.nn = 0;
  }
  sn() {
    return ++this.nn;
  }
  rn(t2) {
    const e = [t2, this.sn()];
    if (this.buffer.size < this.en)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      wr(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var gr = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.on = false, this.cn = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.un(t2);
  }
  stop() {
    this.cn && (this.cn.cancel(), this.cn = null);
  }
  get started() {
    return this.cn !== null;
  }
  un(t2) {
    const e = this.on ? 3e5 : 6e4;
    M2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.cn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.cn = null, this.on = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        ui(t3) ? M2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await _r(t3);
      }
      await this.un(t2);
    });
  }
};
var yr = class {
  constructor(t2, e) {
    this.an = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.an.hn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return si.resolve(nt.A);
    const n = new mr(e);
    return this.an.forEachTarget(t2, (t3) => n.rn(t3.sequenceNumber)).next(() => this.an.ln(t2, (t3) => n.rn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.an.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.an.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (M2("LruGarbageCollector", "Garbage collection skipped; disabled"), si.resolve(tr)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (M2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), tr) : this.fn(t2, e));
  }
  getCacheSize(t2) {
    return this.an.getCacheSize(t2);
  }
  fn(t2, e) {
    let n, s, i, r, o, u, a;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (M2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, u = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (a = Date.now(), k2() <= LogLevel.DEBUG) {
        M2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (u - o) + `ms
	Removed ${t3} documents in ` + (a - u) + `ms
Total Duration: ${a - h}ms`);
      }
      return si.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var pr = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new yr(t3, e2);
    }(this, e);
  }
  hn(t2) {
    const e = this.dn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  dn(t2) {
    let e = 0;
    return this.ln(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  ln(t2, e) {
    return this._n(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Ir(t2, n);
  }
  removeReference(t2, e, n) {
    return Ir(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Ir(t2, e);
  }
  wn(t2, e) {
    return function(t3, e2) {
      let n = false;
      return ur(t3).Wt((s) => rr(t3, s, e2).next((t4) => (t4 && (n = true), si.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this._n(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.wn(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, at.min()), dr(t2).delete([0, Vs(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => si.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Ir(t2, e);
  }
  _n(t2, e) {
    const n = dr(t2);
    let s, i = nt.A;
    return n.Qt({
      index: qs.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== nt.A && e(new Nt(Cs(s)), i), i = o, s = r) : i = nt.A;
    }).next(() => {
      i !== nt.A && e(new Nt(Cs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Ir(t2, e) {
  return dr(t2).put(function(t3, e2) {
    return new qs(0, Vs(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var Er = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ft(this.inner);
  }
};
var Tr = class {
  constructor() {
    this.changes = new Er((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, Jt.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? si.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Ar = class {
  constructor(t2) {
    this.O = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return br(t2).put(vr(e), n);
  }
  removeEntry(t2, e) {
    const n = br(t2), s = vr(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.mn(t2, n)));
  }
  getEntry(t2, e) {
    return br(t2).get(vr(e)).next((t3) => this.gn(e, t3));
  }
  yn(t2, e) {
    return br(t2).get(vr(e)).next((t3) => ({
      document: this.gn(e, t3),
      size: sr(t3)
    }));
  }
  getEntries(t2, e) {
    let n = Dn();
    return this.pn(t2, e, (t3, e2) => {
      const s = this.gn(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  In(t2, e) {
    let n = Dn(), s = new An(Nt.comparator);
    return this.pn(t2, e, (t3, e2) => {
      const i = this.gn(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, sr(e2));
    }).next(() => ({
      documents: n,
      En: s
    }));
  }
  pn(t2, e, n) {
    if (e.isEmpty())
      return si.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return br(t2).Qt({
      range: s
    }, (t3, e2, s2) => {
      const o = Nt.fromSegments(t3);
      for (; r && Nt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Ut(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getAll(t2, e, n) {
    let s = Dn();
    const i = e.length + 1, r = {};
    if (n.isEqual(at.min())) {
      const t3 = e.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.toArray(), s2 = Ti(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Bs.collectionReadTimeIndex;
    }
    return br(t2).Qt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = this.gn(Nt.fromSegments(t3), n2);
      e.isPrefixOf(o.key.path) ? s = s.insert(o.key, o) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Rr(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Pr(t2).get(Ls.key).next((t3) => (U2(!!t3), t3));
  }
  mn(t2, e) {
    return Pr(t2).put(Ls.key, e);
  }
  gn(t2, e) {
    if (e) {
      const t3 = Ii(this.O, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(at.min())))
        return t3;
    }
    return Jt.newInvalidDocument(t2);
  }
};
var Rr = class extends Tr {
  constructor(t2, e) {
    super(), this.Tn = t2, this.trackRemovals = e, this.An = new Er((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new bn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.An.get(i);
      if (r.isValidDocument()) {
        const c = Ei(this.Tn.O, r);
        s = s.add(i.path.popLast());
        const u = sr(c);
        n += u - o, e.push(this.Tn.addEntry(t2, i, c));
      } else if (n -= o, this.trackRemovals) {
        const n2 = Ei(this.Tn.O, r.convertToNoDocument(at.min()));
        e.push(this.Tn.addEntry(t2, i, n2));
      } else
        e.push(this.Tn.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Tn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Tn.updateMetadata(t2, n)), si.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Tn.yn(t2, e).next((t3) => (this.An.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Tn.In(t2, e).next(({ documents: t3, En: e2 }) => (e2.forEach((t4, e3) => {
      this.An.set(t4, e3);
    }), t3));
  }
};
function Pr(t2) {
  return _i(t2, Ls.store);
}
function br(t2) {
  return _i(t2, Bs.store);
}
function vr(t2) {
  return t2.path.toArray();
}
var Vr = class {
  constructor(t2) {
    this.O = t2;
  }
  kt(t2, e, n, s) {
    const i = new ii("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(xs.store);
    }(t2), function(t3) {
      t3.createObjectStore(ks.store, {
        keyPath: ks.keyPath
      });
      t3.createObjectStore(Os.store, {
        keyPath: Os.keyPath,
        autoIncrement: true
      }).createIndex(Os.userMutationsIndex, Os.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(Ms.store);
    }(t2), Sr(t2), function(t3) {
      t3.createObjectStore(Bs.store);
    }(t2));
    let r = si.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(qs.store), t3.deleteObjectStore(Us.store), t3.deleteObjectStore(Ks.store);
    }(t2), Sr(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(Ks.store), n2 = new Ks(0, 0, at.min().toTimestamp(), 0);
      return e2.put(Ks.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(Os.store).qt().next((n2) => {
        t3.deleteObjectStore(Os.store);
        t3.createObjectStore(Os.store, {
          keyPath: Os.keyPath,
          autoIncrement: true
        }).createIndex(Os.userMutationsIndex, Os.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(Os.store), i2 = n2.map((t4) => s2.put(t4));
        return si.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(js.store, {
          keyPath: js.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Rn(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Ls.store);
    }(t2), this.Pn(i)))), n < 7 && s >= 7 && (r = r.next(() => this.bn(i))), n < 8 && s >= 8 && (r = r.next(() => this.vn(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Bs.store);
        e2.createIndex(Bs.readTimeIndex, Bs.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Bs.collectionReadTimeIndex, Bs.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Vn(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Qs.store, {
          keyPath: Qs.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Ws.store, {
          keyPath: Ws.keyPath
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore(Ys.store, {
          keyPath: Ys.keyPath
        });
        e2.createIndex(Ys.collectionPathOverlayIndex, Ys.collectionPathOverlayIndexPath, {
          unique: false
        }), e2.createIndex(Ys.collectionGroupOverlayIndex, Ys.collectionGroupOverlayIndexPath, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(zs.store, {
          keyPath: zs.keyPath,
          autoIncrement: true
        }).createIndex(zs.collectionGroupIndex, zs.collectionGroupIndexPath, {
          unique: false
        });
        t3.createObjectStore(Hs.store, {
          keyPath: Hs.keyPath
        }).createIndex(Hs.sequenceNumberIndex, Hs.sequenceNumberIndexPath, {
          unique: false
        });
        t3.createObjectStore(Js.store, {
          keyPath: Js.keyPath
        }).createIndex(Js.documentKeyIndex, Js.documentKeyIndexPath, {
          unique: false
        });
      }(t2);
    })), r;
  }
  Pn(t2) {
    let e = 0;
    return t2.store(Bs.store).Qt((t3, n) => {
      e += sr(n);
    }).next(() => {
      const n = new Ls(e);
      return t2.store(Ls.store).put(Ls.key, n);
    });
  }
  Rn(t2) {
    const e = t2.store(ks.store), n = t2.store(Os.store);
    return e.qt().next((e2) => si.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.qt(Os.userMutationsIndex, s).next((n2) => si.forEach(n2, (n3) => {
        U2(n3.userId === e3.userId);
        const s2 = bi(this.O, n3);
        return nr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  bn(t2) {
    const e = t2.store(qs.store), n = t2.store(Bs.store);
    return t2.store(Ks.store).get(Ks.key).next((t3) => {
      const s = [];
      return n.Qt((n2, i) => {
        const r = new _t(n2), o = function(t4) {
          return [0, Vs(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? si.resolve() : ((n4) => e.put(new qs(0, Vs(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => si.waitFor(s));
    });
  }
  vn(t2, e) {
    t2.createObjectStore(Gs.store, {
      keyPath: Gs.keyPath
    });
    const n = e.store(Gs.store), s = new zi(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Vs(s2)
        });
      }
    };
    return e.store(Bs.store).Qt({
      jt: true
    }, (t3, e2) => {
      const n2 = new _t(t3);
      return i(n2.popLast());
    }).next(() => e.store(Ms.store).Qt({
      jt: true
    }, ([t3, e2, n2], s2) => {
      const r = Cs(e2);
      return i(r.popLast());
    }));
  }
  Vn(t2) {
    const e = t2.store(Us.store);
    return e.Qt((t3, n) => {
      const s = vi(n), i = Vi(this.O, s);
      return e.put(i);
    });
  }
};
function Sr(t2) {
  t2.createObjectStore(qs.store, {
    keyPath: qs.keyPath
  }).createIndex(qs.documentTargetsIndex, qs.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(Us.store, {
    keyPath: Us.keyPath
  }).createIndex(Us.queryTargetsIndexName, Us.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(Ks.store);
}
var Dr = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Cr = class {
  constructor(t2, e, n, s, i, r, o, c, u, a, h = 12) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Sn = i, this.window = r, this.document = o, this.Dn = u, this.Cn = a, this.schemaVersion = h, this.Nn = null, this.xn = false, this.isPrimary = false, this.networkEnabled = true, this.kn = null, this.inForeground = false, this.On = null, this.Mn = null, this.$n = Number.NEGATIVE_INFINITY, this.Fn = (t3) => Promise.resolve(), !Cr.Vt())
      throw new j(G.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new pr(this, s), this.Bn = e + "main", this.O = new pi(c), this.Ln = new ri(this.Bn, this.schemaVersion, new Vr(this.O)), this.Un = new hr(this.referenceDelegate, this.O), this.qn = function(t3) {
      return new Ar(t3);
    }(this.O), this.Kn = new Ni(), this.window && this.window.localStorage ? this.Gn = this.window.localStorage : (this.Gn = null, a === false && $("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.jn().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new j(G.FAILED_PRECONDITION, Dr);
      return this.Qn(), this.Wn(), this.zn(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.Un.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Nn = new nt(t2, this.Dn);
    }).then(() => {
      this.xn = true;
    }).catch((t2) => (this.Ln && this.Ln.close(), Promise.reject(t2)));
  }
  Hn(t2) {
    return this.Fn = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Ln.Mt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Sn.enqueueAndForget(async () => {
      this.started && await this.jn();
    }));
  }
  jn() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => xr(t2).put(new js(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.Jn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Sn.enqueueRetryable(() => this.Fn(false)));
        });
    }).next(() => this.Yn(t2)).next((e) => this.isPrimary && !e ? this.Xn(t2).next(() => false) : !!e && this.Zn(t2).next(() => true))).catch((t2) => {
      if (ui(t2))
        return M2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return M2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Sn.enqueueRetryable(() => this.Fn(t2)), this.isPrimary = t2;
    });
  }
  Jn(t2) {
    return Nr(t2).get(xs.key).next((t3) => si.resolve(this.ts(t3)));
  }
  es(t2) {
    return xr(t2).delete(this.clientId);
  }
  async ns() {
    if (this.isPrimary && !this.ss(this.$n, 18e5)) {
      this.$n = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = _i(t3, js.store);
        return e.qt().next((t4) => {
          const n = this.rs(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return si.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Gn)
        for (const e of t2)
          this.Gn.removeItem(this.os(e.clientId));
    }
  }
  zn() {
    this.Mn = this.Sn.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.jn().then(() => this.ns()).then(() => this.zn()));
  }
  ts(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  Yn(t2) {
    if (this.Cn)
      return si.resolve(true);
    return Nr(t2).get(xs.key).next((e) => {
      if (e !== null && this.ss(e.leaseTimestampMs, 5e3) && !this.cs(e.ownerId)) {
        if (this.ts(e) && this.networkEnabled)
          return true;
        if (!this.ts(e)) {
          if (!e.allowTabSynchronization)
            throw new j(G.FAILED_PRECONDITION, Dr);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || xr(t2).qt().next((t3) => this.rs(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && M2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.xn = false, this.us(), this.Mn && (this.Mn.cancel(), this.Mn = null), this.hs(), this.ls(), await this.Ln.runTransaction("shutdown", "readwrite", [xs.store, js.store], (t2) => {
      const e = new di(t2, nt.A);
      return this.Xn(e).next(() => this.es(e));
    }), this.Ln.close(), this.fs();
  }
  rs(t2, e) {
    return t2.filter((t3) => this.ss(t3.updateTimeMs, e) && !this.cs(t3.clientId));
  }
  ds() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => xr(t2).qt().next((t3) => this.rs(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.xn;
  }
  getMutationQueue(t2, e) {
    return ir.Jt(t2, this.O, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Un;
  }
  getRemoteDocumentCache() {
    return this.qn;
  }
  getIndexManager(t2) {
    return new Hi(t2);
  }
  getDocumentOverlayCache(t2) {
    return Oi.Jt(this.O, t2);
  }
  getBundleCache() {
    return this.Kn;
  }
  runTransaction(t2, e, n) {
    M2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite", i = (r = this.schemaVersion) === 13 ? ti : r === 12 ? Zs : r === 11 ? Xs : void L2();
    var r;
    let o;
    return this.Ln.runTransaction(t2, s, i, (s2) => (o = new di(s2, this.Nn ? this.Nn.next() : nt.A), e === "readwrite-primary" ? this.Jn(o).next((t3) => !!t3 || this.Yn(o)).next((e2) => {
      if (!e2)
        throw $(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Sn.enqueueRetryable(() => this.Fn(false)), new j(G.FAILED_PRECONDITION, ei);
      return n(o);
    }).next((t3) => this.Zn(o).next(() => t3)) : this._s(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  _s(t2) {
    return Nr(t2).get(xs.key).next((t3) => {
      if (t3 !== null && this.ss(t3.leaseTimestampMs, 5e3) && !this.cs(t3.ownerId) && !this.ts(t3) && !(this.Cn || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new j(G.FAILED_PRECONDITION, Dr);
    });
  }
  Zn(t2) {
    const e = new xs(this.clientId, this.allowTabSynchronization, Date.now());
    return Nr(t2).put(xs.key, e);
  }
  static Vt() {
    return ri.Vt();
  }
  Xn(t2) {
    const e = Nr(t2);
    return e.get(xs.key).next((t3) => this.ts(t3) ? (M2("IndexedDbPersistence", "Releasing primary lease."), e.delete(xs.key)) : si.resolve());
  }
  ss(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || ($(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  Qn() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.On = () => {
      this.Sn.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.jn()));
    }, this.document.addEventListener("visibilitychange", this.On), this.inForeground = this.document.visibilityState === "visible");
  }
  hs() {
    this.On && (this.document.removeEventListener("visibilitychange", this.On), this.On = null);
  }
  Wn() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.kn = () => {
      this.us(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Sn.enterRestrictedMode(true), this.Sn.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.kn));
  }
  ls() {
    this.kn && (this.window.removeEventListener("pagehide", this.kn), this.kn = null);
  }
  cs(t2) {
    var e;
    try {
      const n = ((e = this.Gn) === null || e === void 0 ? void 0 : e.getItem(this.os(t2))) !== null;
      return M2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return $("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  us() {
    if (this.Gn)
      try {
        this.Gn.setItem(this.os(this.clientId), String(Date.now()));
      } catch (t2) {
        $("Failed to set zombie client id.", t2);
      }
  }
  fs() {
    if (this.Gn)
      try {
        this.Gn.removeItem(this.os(this.clientId));
      } catch (t2) {
      }
  }
  os(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function Nr(t2) {
  return _i(t2, xs.store);
}
function xr(t2) {
  return _i(t2, js.store);
}
function kr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var Or = class {
  constructor(t2, e) {
    this.progress = t2, this.ws = e;
  }
};
var Mr = class {
  constructor(t2, e, n) {
    this.qn = t2, this.gs = e, this.indexManager = n;
  }
  ys(t2, e) {
    return this.gs.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.ps(t2, e, n));
  }
  ps(t2, e, n) {
    return this.qn.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  Is(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  Es(t2, e) {
    return this.qn.getEntries(t2, e).next((e2) => this.Ts(t2, e2).next(() => e2));
  }
  Ts(t2, e) {
    return this.gs.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.Is(e, t3));
  }
  As(t2, e, n) {
    return function(t3) {
      return Nt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Rs(t2, e.path) : Ve(e) ? this.Ps(t2, e, n) : this.bs(t2, e, n);
  }
  Rs(t2, e) {
    return this.ys(t2, new Nt(e)).next((t3) => {
      let e2 = Nn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Ps(t2, e, n) {
    const s = e.collectionGroup;
    let i = Nn();
    return this.indexManager.getCollectionParents(t2, s).next((r) => si.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new Ee(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.bs(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  bs(t2, e, n) {
    let s;
    return this.qn.getAll(t2, e.path, n).next((n2) => (s = n2, this.gs.getAllMutationBatchesAffectingQuery(t2, e))).next((t3) => {
      for (const e2 of t3)
        for (const t4 of e2.mutations) {
          const n2 = t4.key;
          let i = s.get(n2);
          i == null && (i = Jt.newInvalidDocument(n2), s = s.insert(n2, i)), cn(t4, i, e2.localWriteTime), i.isFoundDocument() || (s = s.remove(n2));
        }
    }).next(() => (s.forEach((t3, n2) => {
      Oe(e, n2) || (s = s.remove(t3));
    }), s));
  }
};
var $r = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.vs = n, this.Vs = s;
  }
  static Ss(t2, e) {
    let n = On(), s = On();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new $r(t2, e.fromCache, n, s);
  }
};
var Fr = class {
  Ds(t2) {
    this.Cs = t2;
  }
  As(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(at.min()) ? this.Ns(t2, e) : this.Cs.Es(t2, s).next((i) => {
      const r = this.xs(e, i);
      return (Re(e) || Pe(e)) && this.ks(e.limitType, r, s, n) ? this.Ns(t2, e) : (k2() <= LogLevel.DEBUG && M2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), ke(e)), this.Cs.As(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  xs(t2, e) {
    let n = new bn(Me(t2));
    return e.forEach((e2, s) => {
      Oe(t2, s) && (n = n.add(s));
    }), n;
  }
  ks(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Ns(t2, e) {
    return k2() <= LogLevel.DEBUG && M2("QueryEngine", "Using full collection scan to execute query:", ke(e)), this.Cs.As(t2, e, at.min());
  }
};
var Br = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Os = e, this.O = s, this.Ms = new An(rt), this.$s = new Er((t3) => se(t3), re), this.Fs = at.min(), this.Bs = t2.getRemoteDocumentCache(), this.Un = t2.getTargetCache(), this.Kn = t2.getBundleCache(), this.Ls(n);
  }
  Ls(t2) {
    this.indexManager = this.persistence.getIndexManager(t2), this.gs = this.persistence.getMutationQueue(t2, this.indexManager), this.Us = new Mr(this.Bs, this.gs, this.indexManager), this.Bs.setIndexManager(this.indexManager), this.Os.Ds(this.Us);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Ms));
  }
};
function Lr(t2, e, n, s) {
  return new Br(t2, e, n, s);
}
async function Ur(t2, e) {
  const n = K2(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.gs.getAllMutationBatches(t3).next((i) => (s = i, n.Ls(e), n.gs.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = On();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.Us.Es(t3, o).next((t4) => ({
        qs: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function qr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Bs.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = si.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          U2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.gs.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.gs.performConsistencyCheck(t3)).next(() => n.Us.Es(t3, s));
  });
}
function Kr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.Un.getLastRemoteSnapshotVersion(t3));
}
function Gr(t2, e) {
  const n = K2(t2), s = e.snapshotVersion;
  let i = n.Ms;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Bs.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Ms;
    const o = [];
    e.targetChanges.forEach((r2, c2) => {
      const u = i.get(c2);
      if (!u)
        return;
      o.push(n.Un.removeMatchingKeys(t3, r2.removedDocuments, c2).next(() => n.Un.addMatchingKeys(t3, r2.addedDocuments, c2)));
      let a = u.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(c2) ? a = a.withResumeToken(pt.EMPTY_BYTE_STRING, at.min()).withLastLimboFreeSnapshotVersion(at.min()) : r2.resumeToken.approximateByteSize() > 0 && (a = a.withResumeToken(r2.resumeToken, s)), i = i.insert(c2, a), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(u, a, r2) && o.push(n.Un.updateTargetData(t3, a));
    });
    let c = Dn();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(jr(t3, r, e.documentUpdates).next((t4) => {
      c = t4;
    })), !s.isEqual(at.min())) {
      const e2 = n.Un.getLastRemoteSnapshotVersion(t3).next((e3) => n.Un.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return si.waitFor(o).next(() => r.apply(t3)).next(() => n.Us.Ts(t3, c)).next(() => c);
  }).then((t3) => (n.Ms = i, t3));
}
function jr(t2, e, n) {
  let s = On();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = Dn();
    return n.forEach((n2, i) => {
      const r = t3.get(n2);
      i.isNoDocument() && i.version.isEqual(at.min()) ? (e.removeEntry(n2, i.readTime), s2 = s2.insert(n2, i)) : !r.isValidDocument() || i.version.compareTo(r.version) > 0 || i.version.compareTo(r.version) === 0 && r.hasPendingWrites ? (e.addEntry(i), s2 = s2.insert(n2, i)) : M2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", r.version, " Watch version:", i.version);
    }), s2;
  });
}
function Qr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.gs.getNextMutationBatchAfterBatchId(t3, e)));
}
function Wr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.Un.getTargetData(t3, e).next((i) => i ? (s = i, si.resolve(s)) : n.Un.allocateTargetId(t3).next((i2) => (s = new yi(e, i2, 0, t3.currentSequenceNumber), n.Un.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Ms.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Ms = n.Ms.insert(t3.targetId, t3), n.$s.set(e, t3.targetId)), t3;
  });
}
async function zr(t2, e, n) {
  const s = K2(t2), i = s.Ms.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!ui(t3))
      throw t3;
    M2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Ms = s.Ms.remove(e), s.$s.delete(i.target);
}
function Hr(t2, e, n) {
  const s = K2(t2);
  let i = at.min(), r = On();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = K2(t4), i2 = s2.$s.get(n2);
    return i2 !== void 0 ? si.resolve(s2.Ms.get(i2)) : s2.Un.getTargetData(e2, n2);
  }(s, t3, De(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Un.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Os.As(t3, e, n ? i : at.min(), n ? r : On())).next((t4) => ({
    documents: t4,
    Ks: r
  })));
}
function Jr(t2, e) {
  const n = K2(t2), s = K2(n.Un), i = n.Ms.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Tt(t3, e).next((t4) => t4 ? t4.target : null));
}
function Yr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = K2(t4);
    let i = Dn(), r = Ti(n);
    const o = br(e2), c = IDBKeyRange.lowerBound(r, true);
    return o.Qt({
      index: Bs.readTimeIndex,
      range: c
    }, (t5, e3) => {
      const n2 = Ii(s.O, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      ws: i,
      readTime: Ai(r)
    }));
  }(e.Bs, t3, e.Fs)).then(({ ws: t3, readTime: n }) => (e.Fs = n, t3));
}
async function Xr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = br(t4);
    let n = at.min();
    return e2.Qt({
      index: Bs.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = Ai(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.Fs = t3;
  });
}
async function Zr(t2, e, n, s) {
  const i = K2(t2);
  let r = On(), o = Dn();
  for (const t3 of n) {
    const n2 = e.Gs(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.js(t3);
    s2.setReadTime(e.Qs(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const c = i.Bs.newChangeBuffer({
    trackRemovals: true
  }), u = await Wr(i, function(t3) {
    return De(Ae(_t.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => jr(t3, c, o).next((e2) => (c.apply(t3), e2)).next((e2) => i.Un.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.Un.addMatchingKeys(t3, r, u.targetId)).next(() => i.Us.Ts(t3, e2)).next(() => e2)));
}
async function to(t2, e, n = On()) {
  const s = await Wr(t2, De(Si(e.bundledQuery))), i = K2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Zn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Kn.saveNamedQuery(t3, e);
    const o = s.withResumeToken(pt.EMPTY_BYTE_STRING, r);
    return i.Ms = i.Ms.insert(o.targetId, o), i.Un.updateTargetData(t3, o).next(() => i.Un.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.Un.addMatchingKeys(t3, n, s.targetId)).next(() => i.Kn.saveNamedQuery(t3, e));
  });
}
var eo = class {
  constructor(t2) {
    this.O = t2, this.Ws = /* @__PURE__ */ new Map(), this.zs = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return si.resolve(this.Ws.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Ws.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Zn(n.createTime)
    }), si.resolve();
  }
  getNamedQuery(t2, e) {
    return si.resolve(this.zs.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.zs.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: Si(t3.bundledQuery),
        readTime: Zn(t3.readTime)
      };
    }(e)), si.resolve();
  }
};
var no = class {
  constructor() {
    this.overlays = new An(Nt.comparator), this.Hs = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return si.resolve(this.overlays.get(e));
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2) => {
      this.Yt(t2, e, n2);
    }), si.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.Hs.get(n);
    return s !== void 0 && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.Hs.delete(n)), si.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = /* @__PURE__ */ new Map(), i = e.length + 1, r = new Nt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return si.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new An((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        e2 === null && (e2 = /* @__PURE__ */ new Map(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = /* @__PURE__ */ new Map(), c = i.getIterator();
    for (; c.hasNext(); ) {
      if (c.getNext().value.forEach((t3, e2) => o.set(e2, t3)), o.size >= s)
        break;
    }
    return si.resolve(o);
  }
  Yt(t2, e, n) {
    if (n === null)
      return;
    const s = this.overlays.get(n.key);
    s !== null && this.Hs.get(s.largestBatchId).delete(n.key), this.overlays = this.overlays.insert(n.key, new gi(e, n));
    let i = this.Hs.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set(), this.Hs.set(e, i)), i.add(n.key);
  }
};
var so = class {
  constructor() {
    this.Js = new bn(io.Ys), this.Xs = new bn(io.Zs);
  }
  isEmpty() {
    return this.Js.isEmpty();
  }
  addReference(t2, e) {
    const n = new io(t2, e);
    this.Js = this.Js.add(n), this.Xs = this.Xs.add(n);
  }
  ti(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.ei(new io(t2, e));
  }
  ni(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  si(t2) {
    const e = new Nt(new _t([])), n = new io(e, t2), s = new io(e, t2 + 1), i = [];
    return this.Xs.forEachInRange([n, s], (t3) => {
      this.ei(t3), i.push(t3.key);
    }), i;
  }
  ii() {
    this.Js.forEach((t2) => this.ei(t2));
  }
  ei(t2) {
    this.Js = this.Js.delete(t2), this.Xs = this.Xs.delete(t2);
  }
  ri(t2) {
    const e = new Nt(new _t([])), n = new io(e, t2), s = new io(e, t2 + 1);
    let i = On();
    return this.Xs.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new io(t2, 0), n = this.Js.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var io = class {
  constructor(t2, e) {
    this.key = t2, this.oi = e;
  }
  static Ys(t2, e) {
    return Nt.comparator(t2.key, e.key) || rt(t2.oi, e.oi);
  }
  static Zs(t2, e) {
    return rt(t2.oi, e.oi) || Nt.comparator(t2.key, e.key);
  }
};
var ro = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.gs = [], this.ci = 1, this.ui = new bn(io.Ys);
  }
  checkEmpty(t2) {
    return si.resolve(this.gs.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ci;
    this.ci++, this.gs.length > 0 && this.gs[this.gs.length - 1];
    const r = new wi(i, e, n, s);
    this.gs.push(r);
    for (const e2 of s)
      this.ui = this.ui.add(new io(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return si.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return si.resolve(this.ai(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.hi(n), i = s < 0 ? 0 : s;
    return si.resolve(this.gs.length > i ? this.gs[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return si.resolve(this.gs.length === 0 ? -1 : this.ci - 1);
  }
  getAllMutationBatches(t2) {
    return si.resolve(this.gs.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new io(e, 0), s = new io(e, Number.POSITIVE_INFINITY), i = [];
    return this.ui.forEachInRange([n, s], (t3) => {
      const e2 = this.ai(t3.oi);
      i.push(e2);
    }), si.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new bn(rt);
    return e.forEach((t3) => {
      const e2 = new io(t3, 0), s = new io(t3, Number.POSITIVE_INFINITY);
      this.ui.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.oi);
      });
    }), si.resolve(this.li(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    Nt.isDocumentKey(i) || (i = i.child(""));
    const r = new io(new Nt(i), 0);
    let o = new bn(rt);
    return this.ui.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.oi)), true);
    }, r), si.resolve(this.li(o));
  }
  li(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.ai(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    U2(this.fi(e.batchId, "removed") === 0), this.gs.shift();
    let n = this.ui;
    return si.forEach(e.mutations, (s) => {
      const i = new io(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ui = n;
    });
  }
  Qe(t2) {
  }
  containsKey(t2, e) {
    const n = new io(e, 0), s = this.ui.firstAfterOrEqual(n);
    return si.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.gs.length, si.resolve();
  }
  fi(t2, e) {
    return this.hi(t2);
  }
  hi(t2) {
    if (this.gs.length === 0)
      return 0;
    return t2 - this.gs[0].batchId;
  }
  ai(t2) {
    const e = this.hi(t2);
    if (e < 0 || e >= this.gs.length)
      return null;
    return this.gs[e];
  }
};
var oo = class {
  constructor(t2) {
    this.di = t2, this.docs = new An(Nt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.di(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return si.resolve(n ? n.document.mutableCopy() : Jt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = Dn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : Jt.newInvalidDocument(t3));
    }), si.resolve(n);
  }
  getAll(t2, e, n) {
    let s = Dn();
    const i = new Nt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (i2.readTime.compareTo(n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return si.resolve(s);
  }
  _i(t2, e) {
    return si.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new co(this);
  }
  getSize(t2) {
    return si.resolve(this.size);
  }
};
var co = class extends Tr {
  constructor(t2) {
    super(), this.Tn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.Tn.addEntry(t2, s)) : this.Tn.removeEntry(n);
    }), si.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Tn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Tn.getEntries(t2, e);
  }
};
var uo = class {
  constructor(t2) {
    this.persistence = t2, this.wi = new Er((t3) => se(t3), re), this.lastRemoteSnapshotVersion = at.min(), this.highestTargetId = 0, this.mi = 0, this.gi = new so(), this.targetCount = 0, this.yi = ar.He();
  }
  forEachTarget(t2, e) {
    return this.wi.forEach((t3, n) => e(n)), si.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return si.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return si.resolve(this.mi);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.yi.next(), si.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.mi && (this.mi = e), si.resolve();
  }
  Ze(t2) {
    this.wi.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.yi = new ar(e), this.highestTargetId = e), t2.sequenceNumber > this.mi && (this.mi = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.Ze(e), this.targetCount += 1, si.resolve();
  }
  updateTargetData(t2, e) {
    return this.Ze(e), si.resolve();
  }
  removeTargetData(t2, e) {
    return this.wi.delete(e.target), this.gi.si(e.targetId), this.targetCount -= 1, si.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.wi.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.wi.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), si.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return si.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.wi.get(e) || null;
    return si.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.gi.ti(e, n), si.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.gi.ni(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), si.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.gi.si(e), si.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.gi.ri(e);
    return si.resolve(n);
  }
  containsKey(t2, e) {
    return si.resolve(this.gi.containsKey(e));
  }
};
var ao = class {
  constructor(t2, e) {
    this.pi = {}, this.overlays = {}, this.Nn = new nt(0), this.xn = false, this.xn = true, this.referenceDelegate = t2(this), this.Un = new uo(this);
    this.indexManager = new Wi(), this.qn = function(t3) {
      return new oo(t3);
    }((t3) => this.referenceDelegate.Ii(t3)), this.O = new pi(e), this.Kn = new eo(this.O);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.xn = false, Promise.resolve();
  }
  get started() {
    return this.xn;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new no(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.pi[t2.toKey()];
    return n || (n = new ro(e, this.referenceDelegate), this.pi[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.Un;
  }
  getRemoteDocumentCache() {
    return this.qn;
  }
  getBundleCache() {
    return this.Kn;
  }
  runTransaction(t2, e, n) {
    M2("MemoryPersistence", "Starting transaction:", t2);
    const s = new ho(this.Nn.next());
    return this.referenceDelegate.Ei(), n(s).next((t3) => this.referenceDelegate.Ti(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ai(t2, e) {
    return si.or(Object.values(this.pi).map((n) => () => n.containsKey(t2, e)));
  }
};
var ho = class extends ni {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var lo = class {
  constructor(t2) {
    this.persistence = t2, this.Ri = new so(), this.Pi = null;
  }
  static bi(t2) {
    return new lo(t2);
  }
  get vi() {
    if (this.Pi)
      return this.Pi;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.Ri.addReference(n, e), this.vi.delete(n.toString()), si.resolve();
  }
  removeReference(t2, e, n) {
    return this.Ri.removeReference(n, e), this.vi.add(n.toString()), si.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.vi.add(e.toString()), si.resolve();
  }
  removeTarget(t2, e) {
    this.Ri.si(e.targetId).forEach((t3) => this.vi.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.vi.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Ei() {
    this.Pi = /* @__PURE__ */ new Set();
  }
  Ti(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return si.forEach(this.vi, (n) => {
      const s = Nt.fromPath(n);
      return this.Vi(t2, s).next((t3) => {
        t3 || e.removeEntry(s, at.min());
      });
    }).next(() => (this.Pi = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Vi(t2, e).next((t3) => {
      t3 ? this.vi.delete(e.toString()) : this.vi.add(e.toString());
    });
  }
  Ii(t2) {
    return 0;
  }
  Vi(t2, e) {
    return si.or([() => si.resolve(this.Ri.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ai(t2, e)]);
  }
};
function fo(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function _o(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function wo(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var mo = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Si(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new j(s.error.code, s.error.message))), r ? new mo(t2, e, s.state, i) : ($("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Di() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var go = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Si(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new j(n.error.code, n.error.message))), i ? new go(t2, n.state, s) : ($("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Di() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var yo = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Si(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = $n();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Ct(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new yo(t2, i) : ($("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var po = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Si(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new po(e.clientId, e.onlineState) : ($("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Io = class {
  constructor() {
    this.activeTargetIds = $n();
  }
  Ci(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ni(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Di() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Eo = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Sn = e, this.persistenceKey = n, this.xi = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.ki = this.Oi.bind(this), this.Mi = new An(rt), this.started = false, this.$i = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.Fi = fo(this.persistenceKey, this.xi), this.Bi = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.Mi = this.Mi.insert(this.xi, new Io()), this.Li = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.Ui = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.qi = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Ki = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Gi = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.ki);
  }
  static Vt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.ds();
    for (const e2 of t2) {
      if (e2 === this.xi)
        continue;
      const t3 = this.getItem(fo(this.persistenceKey, e2));
      if (t3) {
        const n = yo.Si(e2, t3);
        n && (this.Mi = this.Mi.insert(n.clientId, n));
      }
    }
    this.ji();
    const e = this.storage.getItem(this.Ki);
    if (e) {
      const t3 = this.Qi(e);
      t3 && this.Wi(t3);
    }
    for (const t3 of this.$i)
      this.Oi(t3);
    this.$i = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Bi, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.zi(this.Mi);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.Mi.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.Hi(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.Hi(t2, e, n), this.Ji(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(wo(this.persistenceKey, t2));
      if (n) {
        const s = go.Si(t2, n);
        s && (e = s.state);
      }
    }
    return this.Yi.Ci(t2), this.ji(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Yi.Ni(t2), this.ji();
  }
  isLocalQueryTarget(t2) {
    return this.Yi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(wo(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Xi(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.Ji(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Zi(t2);
  }
  notifyBundleLoaded() {
    this.tr();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.ki), this.removeItem(this.Fi), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return M2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    M2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    M2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  Oi(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (M2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.Fi)
        return void $("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Sn.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Li.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.er(e.key);
                return this.nr(t3, null);
              }
              {
                const t3 = this.sr(e.key, e.newValue);
                if (t3)
                  return this.nr(t3.clientId, t3);
              }
            } else if (this.Ui.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.ir(e.key, e.newValue);
                if (t3)
                  return this.rr(t3);
              }
            } else if (this.qi.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.cr(e.key, e.newValue);
                if (t3)
                  return this.ur(t3);
              }
            } else if (e.key === this.Ki) {
              if (e.newValue !== null) {
                const t3 = this.Qi(e.newValue);
                if (t3)
                  return this.Wi(t3);
              }
            } else if (e.key === this.Bi) {
              const t3 = function(t4) {
                let e2 = nt.A;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    U2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    $("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== nt.A && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Gi)
              return this.syncEngine.ar();
          }
        } else
          this.$i.push(e);
      });
    }
  }
  get Yi() {
    return this.Mi.get(this.xi);
  }
  ji() {
    this.setItem(this.Fi, this.Yi.Di());
  }
  Hi(t2, e, n) {
    const s = new mo(this.currentUser, t2, e, n), i = _o(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Di());
  }
  Ji(t2) {
    const e = _o(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Zi(t2) {
    const e = {
      clientId: this.xi,
      onlineState: t2
    };
    this.storage.setItem(this.Ki, JSON.stringify(e));
  }
  Xi(t2, e, n) {
    const s = wo(this.persistenceKey, t2), i = new go(t2, e, n);
    this.setItem(s, i.Di());
  }
  tr() {
    this.setItem(this.Gi, "value-not-used");
  }
  er(t2) {
    const e = this.Li.exec(t2);
    return e ? e[1] : null;
  }
  sr(t2, e) {
    const n = this.er(t2);
    return yo.Si(n, e);
  }
  ir(t2, e) {
    const n = this.Ui.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return mo.Si(new C2(i), s, e);
  }
  cr(t2, e) {
    const n = this.qi.exec(t2), s = Number(n[1]);
    return go.Si(s, e);
  }
  Qi(t2) {
    return po.Si(t2);
  }
  async rr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.hr(t2.batchId, t2.state, t2.error);
    M2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  ur(t2) {
    return this.syncEngine.lr(t2.targetId, t2.state, t2.error);
  }
  nr(t2, e) {
    const n = e ? this.Mi.insert(t2, e) : this.Mi.remove(t2), s = this.zi(this.Mi), i = this.zi(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.dr(r, o).then(() => {
      this.Mi = n;
    });
  }
  Wi(t2) {
    this.Mi.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  zi(t2) {
    let e = $n();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var To = class {
  constructor() {
    this._r = new Io(), this.wr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this._r.Ci(t2), this.wr[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.wr[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this._r.Ni(t2);
  }
  isLocalQueryTarget(t2) {
    return this._r.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.wr[t2];
  }
  getAllActiveQueryTargets() {
    return this._r.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this._r.activeTargetIds.has(t2);
  }
  start() {
    return this._r = new Io(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var Ao = class {
  mr(t2) {
  }
  shutdown() {
  }
};
var Ro = class {
  constructor() {
    this.gr = () => this.yr(), this.pr = () => this.Ir(), this.Er = [], this.Tr();
  }
  mr(t2) {
    this.Er.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.gr), window.removeEventListener("offline", this.pr);
  }
  Tr() {
    window.addEventListener("online", this.gr), window.addEventListener("offline", this.pr);
  }
  yr() {
    M2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Er)
      t2(0);
  }
  Ir() {
    M2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Er)
      t2(1);
  }
  static Vt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Po = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var bo = class {
  constructor(t2) {
    this.Ar = t2.Ar, this.Rr = t2.Rr;
  }
  Pr(t2) {
    this.br = t2;
  }
  vr(t2) {
    this.Vr = t2;
  }
  onMessage(t2) {
    this.Sr = t2;
  }
  close() {
    this.Rr();
  }
  send(t2) {
    this.Ar(t2);
  }
  Dr() {
    this.br();
  }
  Cr(t2) {
    this.Vr(t2);
  }
  Nr(t2) {
    this.Sr(t2);
  }
};
var vo = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.kr = e + "://" + t2.host, this.Or = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Mr(t2, e, n, s, i) {
    const r = this.$r(t2, e);
    M2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.Fr(o, s, i), this.Br(t2, r, o, n).then((t3) => (M2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw F2("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  Lr(t2, e, n, s, i) {
    return this.Mr(t2, e, n, s, i);
  }
  Fr(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + N2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  $r(t2, e) {
    const n = Po[t2];
    return `${this.kr}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  Br(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              M2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              M2("Connection", 'RPC "' + t2 + '" timed out'), r(new j(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (M2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e4) >= 0 ? e4 : G.UNKNOWN;
                  }(t3.status);
                  r(new j(e3, t3.message));
                } else
                  r(new j(G.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new j(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          M2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const c = JSON.stringify(s);
      o.send(e, "POST", c, n, 15);
    });
  }
  Ur(t2, e, n) {
    const s = [this.kr, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.Fr(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const c = s.join("");
    M2("Connection", "Creating WebChannel: " + c, o);
    const u = i.createWebChannel(c, o);
    let a = false, h = false;
    const l2 = new bo({
      Ar: (t3) => {
        h ? M2("Connection", "Not sending because WebChannel is closed:", t3) : (a || (M2("Connection", "Opening WebChannel transport."), u.open(), a = true), M2("Connection", "WebChannel sending:", t3), u.send(t3));
      },
      Rr: () => u.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(u, WebChannel.EventType.OPEN, () => {
      h || M2("Connection", "WebChannel transport opened.");
    }), y2(u, WebChannel.EventType.CLOSE, () => {
      h || (h = true, M2("Connection", "WebChannel transport closed"), l2.Cr());
    }), y2(u, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, F2("Connection", "WebChannel transport errored:", t3), l2.Cr(new j(G.UNAVAILABLE, "The operation could not be completed")));
    }), y2(u, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        U2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          M2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = pn[t5];
            if (e4 !== void 0)
              return Tn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = G.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.Cr(new j(e3, n3)), u.close();
        } else
          M2("Connection", "WebChannel received:", n2), l2.Nr(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? M2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && M2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.Dr();
    }, 0), l2;
  }
};
function Vo() {
  return typeof window != "undefined" ? window : null;
}
function So() {
  return typeof document != "undefined" ? document : null;
}
function Do(t2) {
  return new Hn(t2, true);
}
var Co = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Sn = t2, this.timerId = e, this.qr = n, this.Kr = s, this.Gr = i, this.jr = 0, this.Qr = null, this.Wr = Date.now(), this.reset();
  }
  reset() {
    this.jr = 0;
  }
  zr() {
    this.jr = this.Gr;
  }
  Hr(t2) {
    this.cancel();
    const e = Math.floor(this.jr + this.Jr()), n = Math.max(0, Date.now() - this.Wr), s = Math.max(0, e - n);
    s > 0 && M2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.jr} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Qr = this.Sn.enqueueAfterDelay(this.timerId, s, () => (this.Wr = Date.now(), t2())), this.jr *= this.Kr, this.jr < this.qr && (this.jr = this.qr), this.jr > this.Gr && (this.jr = this.Gr);
  }
  Yr() {
    this.Qr !== null && (this.Qr.skipDelay(), this.Qr = null);
  }
  cancel() {
    this.Qr !== null && (this.Qr.cancel(), this.Qr = null);
  }
  Jr() {
    return (Math.random() - 0.5) * this.jr;
  }
};
var No = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.Sn = t2, this.Xr = n, this.Zr = s, this.eo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = c, this.state = 0, this.no = 0, this.so = null, this.io = null, this.stream = null, this.ro = new Co(t2, e);
  }
  oo() {
    return this.state === 1 || this.state === 5 || this.co();
  }
  co() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.uo();
  }
  async stop() {
    this.oo() && await this.close(0);
  }
  ao() {
    this.state = 0, this.ro.reset();
  }
  ho() {
    this.co() && this.so === null && (this.so = this.Sn.enqueueAfterDelay(this.Xr, 6e4, () => this.lo()));
  }
  fo(t2) {
    this._o(), this.stream.send(t2);
  }
  async lo() {
    if (this.co())
      return this.close(0);
  }
  _o() {
    this.so && (this.so.cancel(), this.so = null);
  }
  wo() {
    this.io && (this.io.cancel(), this.io = null);
  }
  async close(t2, e) {
    this._o(), this.wo(), this.ro.cancel(), this.no++, t2 !== 4 ? this.ro.reset() : e && e.code === G.RESOURCE_EXHAUSTED ? ($(e.toString()), $("Using maximum backoff delay to prevent overloading the backend."), this.ro.zr()) : e && e.code === G.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.mo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.vr(e);
  }
  mo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.yo(this.no), e = this.no;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.no === e && this.po(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new j(G.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Io(t3);
      });
    });
  }
  po(t2, e) {
    const n = this.yo(this.no);
    this.stream = this.Eo(t2, e), this.stream.Pr(() => {
      n(() => (this.state = 2, this.io = this.Sn.enqueueAfterDelay(this.Zr, 1e4, () => (this.co() && (this.state = 3), Promise.resolve())), this.listener.Pr()));
    }), this.stream.vr((t3) => {
      n(() => this.Io(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  uo() {
    this.state = 5, this.ro.Hr(async () => {
      this.state = 0, this.start();
    });
  }
  Io(t2) {
    return M2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  yo(t2) {
    return (e) => {
      this.Sn.enqueueAndForget(() => this.no === t2 ? e() : (M2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var xo = class extends No {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.O = i;
  }
  Eo(t2, e) {
    return this.eo.Ur("Listen", t2, e);
  }
  onMessage(t2) {
    this.ro.reset();
    const e = ls(this.O, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return at.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? at.min() : e2.readTime ? Zn(e2.readTime) : at.min();
    }(t2);
    return this.listener.To(e, n);
  }
  Ao(t2) {
    const e = {};
    e.database = os(this.O), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = oe(s) ? {
        documents: ws(t3, s)
      } : {
        query: ms(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Yn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(at.min()) > 0 && (n2.readTime = Jn(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.O, t2);
    const n = ys(this.O, t2);
    n && (e.labels = n), this.fo(e);
  }
  Ro(t2) {
    const e = {};
    e.database = os(this.O), e.removeTarget = t2, this.fo(e);
  }
};
var ko = class extends No {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.O = i, this.Po = false;
  }
  get bo() {
    return this.Po;
  }
  start() {
    this.Po = false, this.lastStreamToken = void 0, super.start();
  }
  mo() {
    this.Po && this.vo([]);
  }
  Eo(t2, e) {
    return this.eo.Ur("Write", t2, e);
  }
  onMessage(t2) {
    if (U2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Po) {
      this.ro.reset();
      const e = _s(t2.writeResults, t2.commitTime), n = Zn(t2.commitTime);
      return this.listener.Vo(n, e);
    }
    return U2(!t2.writeResults || t2.writeResults.length === 0), this.Po = true, this.listener.So();
  }
  Do() {
    const t2 = {};
    t2.database = os(this.O), this.fo(t2);
  }
  vo(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => fs(this.O, t3))
    };
    this.fo(e);
  }
};
var Oo = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.eo = n, this.O = s, this.Co = false;
  }
  No() {
    if (this.Co)
      throw new j(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Mr(t2, e, n) {
    return this.No(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.eo.Mr(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new j(G.UNKNOWN, t3.toString());
    });
  }
  Lr(t2, e, n) {
    return this.No(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.eo.Lr(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new j(G.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Co = true;
  }
};
var Mo = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.xo = 0, this.ko = null, this.Oo = true;
  }
  Mo() {
    this.xo === 0 && (this.$o("Unknown"), this.ko = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ko = null, this.Fo("Backend didn't respond within 10 seconds."), this.$o("Offline"), Promise.resolve())));
  }
  Bo(t2) {
    this.state === "Online" ? this.$o("Unknown") : (this.xo++, this.xo >= 1 && (this.Lo(), this.Fo(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.$o("Offline")));
  }
  set(t2) {
    this.Lo(), this.xo = 0, t2 === "Online" && (this.Oo = false), this.$o(t2);
  }
  $o(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Fo(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.Oo ? ($(e), this.Oo = false) : M2("OnlineStateTracker", e);
  }
  Lo() {
    this.ko !== null && (this.ko.cancel(), this.ko = null);
  }
};
var $o = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Uo = [], this.qo = /* @__PURE__ */ new Map(), this.Ko = /* @__PURE__ */ new Set(), this.Go = [], this.jo = i, this.jo.mr((t3) => {
      n.enqueueAndForget(async () => {
        Qo(this) && (M2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = K2(t4);
          e2.Ko.add(4), await Bo(e2), e2.Qo.set("Unknown"), e2.Ko.delete(4), await Fo(e2);
        }(this));
      });
    }), this.Qo = new Mo(n, s);
  }
};
async function Fo(t2) {
  if (Qo(t2))
    for (const e of t2.Go)
      await e(true);
}
async function Bo(t2) {
  for (const e of t2.Go)
    await e(false);
}
function Lo(t2, e) {
  const n = K2(t2);
  n.qo.has(e.targetId) || (n.qo.set(e.targetId, e), jo(n) ? Go(n) : hc2(n).co() && qo(n, e));
}
function Uo(t2, e) {
  const n = K2(t2), s = hc2(n);
  n.qo.delete(e), s.co() && Ko(n, e), n.qo.size === 0 && (s.co() ? s.ho() : Qo(n) && n.Qo.set("Unknown"));
}
function qo(t2, e) {
  t2.Wo.Z(e.targetId), hc2(t2).Ao(e);
}
function Ko(t2, e) {
  t2.Wo.Z(e), hc2(t2).Ro(e);
}
function Go(t2) {
  t2.Wo = new Gn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Tt: (e) => t2.qo.get(e) || null
  }), hc2(t2).start(), t2.Qo.Mo();
}
function jo(t2) {
  return Qo(t2) && !hc2(t2).oo() && t2.qo.size > 0;
}
function Qo(t2) {
  return K2(t2).Ko.size === 0;
}
function Wo(t2) {
  t2.Wo = void 0;
}
async function zo(t2) {
  t2.qo.forEach((e, n) => {
    qo(t2, e);
  });
}
async function Ho(t2, e) {
  Wo(t2), jo(t2) ? (t2.Qo.Bo(e), Go(t2)) : t2.Qo.set("Unknown");
}
async function Jo(t2, e, n) {
  if (t2.Qo.set("Online"), e instanceof qn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.qo.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.qo.delete(s), t3.Wo.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      M2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Yo(t2, n2);
    }
  else if (e instanceof Ln ? t2.Wo.ct(e) : e instanceof Un ? t2.Wo._t(e) : t2.Wo.ht(e), !n.isEqual(at.min()))
    try {
      const e2 = await Kr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Wo.yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.qo.get(s);
            i && t3.qo.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.qo.get(e4);
          if (!n3)
            return;
          t3.qo.set(e4, n3.withResumeToken(pt.EMPTY_BYTE_STRING, n3.snapshotVersion)), Ko(t3, e4);
          const s = new yi(n3.target, e4, 1, n3.sequenceNumber);
          qo(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      M2("RemoteStore", "Failed to raise snapshot:", e2), await Yo(t2, e2);
    }
}
async function Yo(t2, e, n) {
  if (!ui(e))
    throw e;
  t2.Ko.add(1), await Bo(t2), t2.Qo.set("Offline"), n || (n = () => Kr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    M2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Ko.delete(1), await Fo(t2);
  });
}
function Xo(t2, e) {
  return e().catch((n) => Yo(t2, n, e));
}
async function Zo(t2) {
  const e = K2(t2), n = lc2(e);
  let s = e.Uo.length > 0 ? e.Uo[e.Uo.length - 1].batchId : -1;
  for (; tc2(e); )
    try {
      const t3 = await Qr(e.localStore, s);
      if (t3 === null) {
        e.Uo.length === 0 && n.ho();
        break;
      }
      s = t3.batchId, ec2(e, t3);
    } catch (t3) {
      await Yo(e, t3);
    }
  nc2(e) && sc2(e);
}
function tc2(t2) {
  return Qo(t2) && t2.Uo.length < 10;
}
function ec2(t2, e) {
  t2.Uo.push(e);
  const n = lc2(t2);
  n.co() && n.bo && n.vo(e.mutations);
}
function nc2(t2) {
  return Qo(t2) && !lc2(t2).oo() && t2.Uo.length > 0;
}
function sc2(t2) {
  lc2(t2).start();
}
async function ic2(t2) {
  lc2(t2).Do();
}
async function rc2(t2) {
  const e = lc2(t2);
  for (const n of t2.Uo)
    e.vo(n.mutations);
}
async function oc2(t2, e, n) {
  const s = t2.Uo.shift(), i = mi.from(s, e, n);
  await Xo(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Zo(t2);
}
async function cc2(t2, e) {
  e && lc2(t2).bo && await async function(t3, e2) {
    if (n = e2.code, En(n) && n !== G.ABORTED) {
      const n2 = t3.Uo.shift();
      lc2(t3).ao(), await Xo(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Zo(t3);
    }
    var n;
  }(t2, e), nc2(t2) && sc2(t2);
}
async function uc2(t2, e) {
  const n = K2(t2);
  n.asyncQueue.verifyOperationInProgress(), M2("RemoteStore", "RemoteStore received new credentials");
  const s = Qo(n);
  n.Ko.add(3), await Bo(n), s && n.Qo.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.Ko.delete(3), await Fo(n);
}
async function ac2(t2, e) {
  const n = K2(t2);
  e ? (n.Ko.delete(2), await Fo(n)) : e || (n.Ko.add(2), await Bo(n), n.Qo.set("Unknown"));
}
function hc2(t2) {
  return t2.zo || (t2.zo = function(t3, e, n) {
    const s = K2(t3);
    return s.No(), new xo(e, s.eo, s.authCredentials, s.appCheckCredentials, s.O, n);
  }(t2.datastore, t2.asyncQueue, {
    Pr: zo.bind(null, t2),
    vr: Ho.bind(null, t2),
    To: Jo.bind(null, t2)
  }), t2.Go.push(async (e) => {
    e ? (t2.zo.ao(), jo(t2) ? Go(t2) : t2.Qo.set("Unknown")) : (await t2.zo.stop(), Wo(t2));
  })), t2.zo;
}
function lc2(t2) {
  return t2.Ho || (t2.Ho = function(t3, e, n) {
    const s = K2(t3);
    return s.No(), new ko(e, s.eo, s.authCredentials, s.appCheckCredentials, s.O, n);
  }(t2.datastore, t2.asyncQueue, {
    Pr: ic2.bind(null, t2),
    vr: cc2.bind(null, t2),
    So: rc2.bind(null, t2),
    Vo: oc2.bind(null, t2)
  }), t2.Go.push(async (e) => {
    e ? (t2.Ho.ao(), await Zo(t2)) : (await t2.Ho.stop(), t2.Uo.length > 0 && (M2("RemoteStore", `Stopping write stream with ${t2.Uo.length} pending writes`), t2.Uo = []));
  })), t2.Ho;
}
var fc2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new Q2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new fc2(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new j(G.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function dc2(t2, e) {
  if ($("AsyncQueue", `${e}: ${t2}`), ui(t2))
    return new j(G.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var _c = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || Nt.comparator(e.key, n.key) : (t3, e) => Nt.comparator(t3.key, e.key), this.keyedMap = Nn(), this.sortedSet = new An(this.comparator);
  }
  static emptySet(t2) {
    return new _c(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof _c))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new _c();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var wc2 = class {
  constructor() {
    this.Jo = new An(Nt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Jo.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.Jo = this.Jo.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.Jo = this.Jo.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.Jo = this.Jo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.Jo = this.Jo.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.Jo = this.Jo.remove(e) : t2.type === 1 && n.type === 2 ? this.Jo = this.Jo.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.Jo = this.Jo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.Jo = this.Jo.insert(e, t2);
  }
  Yo() {
    const t2 = [];
    return this.Jo.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var mc2 = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = c;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new mc2(t2, e, _c.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Ne(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var gc2 = class {
  constructor() {
    this.Xo = void 0, this.listeners = [];
  }
};
var yc2 = class {
  constructor() {
    this.queries = new Er((t2) => xe(t2), Ne), this.onlineState = "Unknown", this.Zo = /* @__PURE__ */ new Set();
  }
};
async function pc2(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new gc2()), i)
    try {
      r.Xo = await n.onListen(s);
    } catch (t3) {
      const n2 = dc2(t3, `Initialization of query '${ke(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.tc(n.onlineState), r.Xo) {
    e.ec(r.Xo) && Ac2(n);
  }
}
async function Ic2(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Ec2(t2, e) {
  const n = K2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.ec(t3) && (s = true);
      i.Xo = t3;
    }
  }
  s && Ac2(n);
}
function Tc2(t2, e, n) {
  const s = K2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Ac2(t2) {
  t2.Zo.forEach((t3) => {
    t3.next();
  });
}
var Rc2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.nc = e, this.sc = false, this.ic = null, this.onlineState = "Unknown", this.options = n || {};
  }
  ec(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new mc2(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.sc ? this.rc(t2) && (this.nc.next(t2), e = true) : this.oc(t2, this.onlineState) && (this.cc(t2), e = true), this.ic = t2, e;
  }
  onError(t2) {
    this.nc.error(t2);
  }
  tc(t2) {
    this.onlineState = t2;
    let e = false;
    return this.ic && !this.sc && this.oc(this.ic, t2) && (this.cc(this.ic), e = true), e;
  }
  oc(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.uc || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  rc(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.ic && this.ic.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  cc(t2) {
    t2 = mc2.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.sc = true, this.nc.next(t2);
  }
};
var Pc2 = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  ac() {
    return "metadata" in this.payload;
  }
};
var bc2 = class {
  constructor(t2) {
    this.O = t2;
  }
  Gs(t2) {
    return ss(this.O, t2);
  }
  js(t2) {
    return t2.metadata.exists ? as(this.O, t2.document, false) : Jt.newNoDocument(this.Gs(t2.metadata.name), this.Qs(t2.metadata.readTime));
  }
  Qs(t2) {
    return Zn(t2);
  }
};
var vc2 = class {
  constructor(t2, e, n) {
    this.hc = t2, this.localStore = e, this.O = n, this.queries = [], this.documents = [], this.progress = Vc2(t2);
  }
  lc(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  fc(t2) {
    const e = /* @__PURE__ */ new Map(), n = new bc2(this.O);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Gs(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || On()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Zr(this.localStore, new bc2(this.O), this.documents, this.hc.id), e = this.fc(this.documents);
    for (const t3 of this.queries)
      await to(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new Or(Object.assign({}, this.progress), t2);
  }
};
function Vc2(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Sc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Dc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Cc2 = class {
  constructor(t2, e) {
    this.query = t2, this.dc = e, this._c = null, this.current = false, this.wc = On(), this.mutatedKeys = On(), this.mc = Me(t2), this.gc = new _c(this.mc);
  }
  get yc() {
    return this.dc;
  }
  Ic(t2, e) {
    const n = e ? e.Ec : new wc2(), s = e ? e.gc : this.gc;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const c = Re(this.query) && s.size === this.query.limit ? s.last() : null, u = Pe(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h = Oe(this.query, e2) ? e2 : null, l2 = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Tc(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (c && this.mc(h, c) > 0 || u && this.mc(h, u) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (c || u) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), Re(this.query) || Pe(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = Re(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      gc: r,
      Ec: n,
      ks: o,
      mutatedKeys: i
    };
  }
  Tc(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.gc;
    this.gc = t2.gc, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Ec.Yo();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.mc(t3.doc, e2.doc)), this.Ac(n);
    const r = e ? this.Rc() : [], o = this.wc.size === 0 && this.current ? 1 : 0, c = o !== this._c;
    if (this._c = o, i.length !== 0 || c) {
      return {
        snapshot: new mc2(this.query, t2.gc, s, i, t2.mutatedKeys, o === 0, c, false),
        Pc: r
      };
    }
    return {
      Pc: r
    };
  }
  tc(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      gc: this.gc,
      Ec: new wc2(),
      mutatedKeys: this.mutatedKeys,
      ks: false
    }, false)) : {
      Pc: []
    };
  }
  bc(t2) {
    return !this.dc.has(t2) && (!!this.gc.has(t2) && !this.gc.get(t2).hasLocalMutations);
  }
  Ac(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.dc = this.dc.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.dc = this.dc.delete(t3)), this.current = t2.current);
  }
  Rc() {
    if (!this.current)
      return [];
    const t2 = this.wc;
    this.wc = On(), this.gc.forEach((t3) => {
      this.bc(t3.key) && (this.wc = this.wc.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.wc.has(t3) || e.push(new Dc2(t3));
    }), this.wc.forEach((n) => {
      t2.has(n) || e.push(new Sc2(n));
    }), e;
  }
  vc(t2) {
    this.dc = t2.Ks, this.wc = On();
    const e = this.Ic(t2.documents);
    return this.applyChanges(e, true);
  }
  Vc() {
    return mc2.fromInitialDocuments(this.query, this.gc, this.mutatedKeys, this._c === 0);
  }
};
var Nc2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var xc2 = class {
  constructor(t2) {
    this.key = t2, this.Sc = false;
  }
};
var kc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Dc = {}, this.Cc = new Er((t3) => xe(t3), Ne), this.Nc = /* @__PURE__ */ new Map(), this.xc = /* @__PURE__ */ new Set(), this.kc = new An(Nt.comparator), this.Oc = /* @__PURE__ */ new Map(), this.Mc = new so(), this.$c = {}, this.Fc = /* @__PURE__ */ new Map(), this.Bc = ar.Je(), this.onlineState = "Unknown", this.Lc = void 0;
  }
  get isPrimaryClient() {
    return this.Lc === true;
  }
};
async function Oc2(t2, e) {
  const n = hu(t2);
  let s, i;
  const r = n.Cc.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Vc();
  else {
    const t3 = await Wr(n.localStore, De(e));
    n.isPrimaryClient && Lo(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Mc2(n, e, s, r2 === "current");
  }
  return i;
}
async function Mc2(t2, e, n, s) {
  t2.Uc = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Ic(n3);
    i2.ks && (i2 = await Hr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Ic(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return Hc2(t3, e3.targetId, o2.Pc), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await Hr(t2.localStore, e, true), r = new Cc2(e, i.Ks), o = r.Ic(i.documents), c = Bn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), u = r.applyChanges(o, t2.isPrimaryClient, c);
  Hc2(t2, n, u.Pc);
  const a = new Nc2(e, n, r);
  return t2.Cc.set(e, a), t2.Nc.has(n) ? t2.Nc.get(n).push(e) : t2.Nc.set(n, [e]), u.snapshot;
}
async function $c2(t2, e) {
  const n = K2(t2), s = n.Cc.get(e), i = n.Nc.get(s.targetId);
  if (i.length > 1)
    return n.Nc.set(s.targetId, i.filter((t3) => !Ne(t3, e))), void n.Cc.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await zr(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), Uo(n.remoteStore, s.targetId), Wc2(n, s.targetId);
    }).catch(_r);
  } else
    Wc2(n, s.targetId), await zr(n.localStore, s.targetId, true);
}
async function Fc2(t2, e, n) {
  const s = lu(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4), s2 = ut.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), On());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Us.Es(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = un(t6, r.get(t6.key));
          e3 != null && o.push(new fn(t6.key, e3, Ht(e3.value.mapValue), nn.exists(true)));
        }
        return n2.gs.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.$c[t4.currentUser.toKey()];
      s2 || (s2 = new An(rt));
      s2 = s2.insert(e2, n2), t4.$c[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Xc2(s, t3.changes), await Zo(s.remoteStore);
  } catch (t3) {
    const e2 = dc2(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function Bc2(t2, e) {
  const n = K2(t2);
  try {
    const t3 = await Gr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Oc.get(e2);
      s && (U2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Sc = true : t4.modifiedDocuments.size > 0 ? U2(s.Sc) : t4.removedDocuments.size > 0 && (U2(s.Sc), s.Sc = false));
    }), await Xc2(n, t3, e);
  } catch (t3) {
    await _r(t3);
  }
}
function Lc2(t2, e, n) {
  const s = K2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.Cc.forEach((n2, s2) => {
      const i = s2.view.tc(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = K2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.tc(e2) && (s2 = true);
      }), s2 && Ac2(n2);
    }(s.eventManager, e), t3.length && s.Dc.To(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function Uc2(t2, e, n) {
  const s = K2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Oc.get(e), r = i && i.key;
  if (r) {
    let t3 = new An(Nt.comparator);
    t3 = t3.insert(r, Jt.newNoDocument(r, at.min()));
    const n2 = On().add(r), i2 = new Fn(at.min(), /* @__PURE__ */ new Map(), new bn(rt), t3, n2);
    await Bc2(s, i2), s.kc = s.kc.remove(r), s.Oc.delete(e), Yc2(s);
  } else
    await zr(s.localStore, e, false).then(() => Wc2(s, e, n)).catch(_r);
}
async function qc2(t2, e) {
  const n = K2(t2), s = e.batch.batchId;
  try {
    const t3 = await qr(n.localStore, e);
    Qc2(n, s, null), jc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Xc2(n, t3);
  } catch (t3) {
    await _r(t3);
  }
}
async function Kc2(t2, e, n) {
  const s = K2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.gs.lookupMutationBatch(t5, e2).next((e3) => (U2(e3 !== null), s2 = e3.keys(), n2.gs.removeMutationBatch(t5, e3))).next(() => n2.gs.performConsistencyCheck(t5)).next(() => n2.Us.Es(t5, s2));
      });
    }(s.localStore, e);
    Qc2(s, e, n), jc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Xc2(s, t3);
  } catch (n2) {
    await _r(n2);
  }
}
async function Gc2(t2, e) {
  const n = K2(t2);
  Qo(n.remoteStore) || M2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = K2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.gs.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.Fc.get(t3) || [];
    s.push(e), n.Fc.set(t3, s);
  } catch (t3) {
    const n2 = dc2(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function jc2(t2, e) {
  (t2.Fc.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.Fc.delete(e);
}
function Qc2(t2, e, n) {
  const s = K2(t2);
  let i = s.$c[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.$c[s.currentUser.toKey()] = i;
  }
}
function Wc2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Nc.get(e))
    t2.Cc.delete(s), n && t2.Dc.qc(s, n);
  if (t2.Nc.delete(e), t2.isPrimaryClient) {
    t2.Mc.si(e).forEach((e2) => {
      t2.Mc.containsKey(e2) || zc2(t2, e2);
    });
  }
}
function zc2(t2, e) {
  t2.xc.delete(e.path.canonicalString());
  const n = t2.kc.get(e);
  n !== null && (Uo(t2.remoteStore, n), t2.kc = t2.kc.remove(e), t2.Oc.delete(n), Yc2(t2));
}
function Hc2(t2, e, n) {
  for (const s of n)
    if (s instanceof Sc2)
      t2.Mc.addReference(s.key, e), Jc2(t2, s);
    else if (s instanceof Dc2) {
      M2("SyncEngine", "Document no longer in limbo: " + s.key), t2.Mc.removeReference(s.key, e);
      t2.Mc.containsKey(s.key) || zc2(t2, s.key);
    } else
      L2();
}
function Jc2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.kc.get(n) || t2.xc.has(s) || (M2("SyncEngine", "New document in limbo: " + n), t2.xc.add(s), Yc2(t2));
}
function Yc2(t2) {
  for (; t2.xc.size > 0 && t2.kc.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.xc.values().next().value;
    t2.xc.delete(e);
    const n = new Nt(_t.fromString(e)), s = t2.Bc.next();
    t2.Oc.set(s, new xc2(n)), t2.kc = t2.kc.insert(n, s), Lo(t2.remoteStore, new yi(De(Ae(n.path)), s, 2, nt.A));
  }
}
async function Xc2(t2, e, n) {
  const s = K2(t2), i = [], r = [], o = [];
  s.Cc.isEmpty() || (s.Cc.forEach((t3, c) => {
    o.push(s.Uc(c, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(c.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = $r.Ss(c.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Dc.To(i), await async function(t3, e2) {
    const n2 = K2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => si.forEach(e2, (e3) => si.forEach(e3.vs, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => si.forEach(e3.Vs, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!ui(t4))
        throw t4;
      M2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Ms.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Ms = n2.Ms.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function Zc2(t2, e) {
  const n = K2(t2);
  if (!n.currentUser.isEqual(e)) {
    M2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await Ur(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.Fc.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new j(G.CANCELLED, e2));
        });
      }), t4.Fc.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Xc2(n, t3.qs);
  }
}
function tu(t2, e) {
  const n = K2(t2), s = n.Oc.get(e);
  if (s && s.Sc)
    return On().add(s.key);
  {
    let t3 = On();
    const s2 = n.Nc.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.Cc.get(e2);
      t3 = t3.unionWith(s3.view.yc);
    }
    return t3;
  }
}
async function eu(t2, e) {
  const n = K2(t2), s = await Hr(n.localStore, e.query, true), i = e.view.vc(s);
  return n.isPrimaryClient && Hc2(n, e.targetId, i.Pc), i;
}
async function nu(t2) {
  const e = K2(t2);
  return Yr(e.localStore).then((t3) => Xc2(e, t3));
}
async function su(t2, e, n, s) {
  const i = K2(t2), r = await function(t3, e2) {
    const n2 = K2(t3), s2 = K2(n2.gs);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Ge(t4, e2).next((e3) => e3 ? n2.Us.Es(t4, e3) : si.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await Zo(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (Qc2(i, e, s || null), jc2(i, e), function(t3, e2) {
    K2(K2(t3).gs).Qe(e2);
  }(i.localStore, e)) : L2(), await Xc2(i, r)) : M2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function iu(t2, e) {
  const n = K2(t2);
  if (hu(n), lu(n), e === true && n.Lc !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await ru(n, t3.toArray());
    n.Lc = true, await ac2(n.remoteStore, true);
    for (const t4 of e2)
      Lo(n.remoteStore, t4);
  } else if (e === false && n.Lc !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.Nc.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (Wc2(n, i), zr(n.localStore, i, true))), Uo(n.remoteStore, i);
    }), await e2, await ru(n, t3), function(t4) {
      const e3 = K2(t4);
      e3.Oc.forEach((t5, n2) => {
        Uo(e3.remoteStore, n2);
      }), e3.Mc.ii(), e3.Oc = /* @__PURE__ */ new Map(), e3.kc = new An(Nt.comparator);
    }(n), n.Lc = false, await ac2(n.remoteStore, false);
  }
}
async function ru(t2, e, n) {
  const s = K2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.Nc.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await Wr(s.localStore, De(n2[0]));
      for (const t4 of n2) {
        const e3 = s.Cc.get(t4), n3 = await eu(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await Jr(s.localStore, t3);
      e2 = await Wr(s.localStore, n3), await Mc2(s, ou(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Dc.To(r), i;
}
function ou(t2) {
  return Te(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function cu(t2) {
  const e = K2(t2);
  return K2(K2(e.localStore).persistence).ds();
}
async function uu(t2, e, n, s) {
  const i = K2(t2);
  if (i.Lc)
    M2("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Nc.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Yr(i.localStore), s2 = Fn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await Xc2(i, t3, s2);
        break;
      }
      case "rejected":
        await zr(i.localStore, e, true), Wc2(i, e, s);
        break;
      default:
        L2();
    }
}
async function au(t2, e, n) {
  const s = hu(t2);
  if (s.Lc) {
    for (const t3 of e) {
      if (s.Nc.has(t3)) {
        M2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await Jr(s.localStore, t3), n2 = await Wr(s.localStore, e2);
      await Mc2(s, ou(e2), n2.targetId, false), Lo(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.Nc.has(t3) && await zr(s.localStore, t3, false).then(() => {
        Uo(s.remoteStore, t3), Wc2(s, t3);
      }).catch(_r);
  }
}
function hu(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Bc2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = tu.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Uc2.bind(null, e), e.Dc.To = Ec2.bind(null, e.eventManager), e.Dc.qc = Tc2.bind(null, e.eventManager), e;
}
function lu(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = qc2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = Kc2.bind(null, e), e;
}
function fu(t2, e, n) {
  const s = K2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = K2(t4), s3 = Zn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Kn.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(Vc2(s2));
      const i = new vc2(s2, t3.localStore, e2.O);
      let r = await e2.Kc();
      for (; r; ) {
        const t4 = await i.lc(r);
        t4 && n2._updateProgress(t4), r = await e2.Kc();
      }
      const o = await i.complete();
      await Xc2(t3, o.ws, void 0), await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Kn.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      F2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var du = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.O = Do(t2.databaseInfo.databaseId), this.sharedClientState = this.Gc(t2), this.persistence = this.jc(t2), await this.persistence.start(), this.gcScheduler = this.Qc(t2), this.localStore = this.Wc(t2);
  }
  Qc(t2) {
    return null;
  }
  Wc(t2) {
    return Lr(this.persistence, new Fr(), t2.initialUser, this.O);
  }
  jc(t2) {
    return new ao(lo.bi, this.O);
  }
  Gc(t2) {
    return new To();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var _u = class extends du {
  constructor(t2, e, n) {
    super(), this.zc = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await Xr(this.localStore), await this.zc.initialize(this, t2), await lu(this.zc.syncEngine), await Zo(this.zc.remoteStore), await this.persistence.Hn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Wc(t2) {
    return Lr(this.persistence, new Fr(), t2.initialUser, this.O);
  }
  Qc(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new gr(e, t2.asyncQueue);
  }
  jc(t2) {
    const e = kr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? er.withCacheSize(this.cacheSizeBytes) : er.DEFAULT;
    return new Cr(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Vo(), So(), this.O, this.sharedClientState, !!this.forceOwnership);
  }
  Gc(t2) {
    return new To();
  }
};
var wu = class extends _u {
  constructor(t2, e) {
    super(t2, e, false), this.zc = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.zc.syncEngine;
    this.sharedClientState instanceof Eo && (this.sharedClientState.syncEngine = {
      hr: su.bind(null, e),
      lr: uu.bind(null, e),
      dr: au.bind(null, e),
      ds: cu.bind(null, e),
      ar: nu.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.Hn(async (t3) => {
      await iu(this.zc.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Gc(t2) {
    const e = Vo();
    if (!Eo.Vt(e))
      throw new j(G.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = kr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Eo(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var mu = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => Lc2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Zc2.bind(null, this.syncEngine), await ac2(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new yc2();
  }
  createDatastore(t2) {
    const e = Do(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new vo(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new Oo(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => Lc2(this.syncEngine, t3, 0), r = Ro.Vt() ? new Ro() : new Ao(), new $o(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const c = new kc2(t3, e2, n, s, i, r);
      return o && (c.Lc = true), c;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = K2(t2);
      M2("RemoteStore", "RemoteStore shutting down."), e.Ko.add(5), await Bo(e), e.jo.shutdown(), e.Qo.set("Unknown");
    }(this.remoteStore);
  }
};
function gu(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var yu = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Hc(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Hc(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Jc() {
    this.muted = true;
  }
  Hc(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var pu = class {
  constructor(t2, e) {
    this.Yc = t2, this.O = e, this.metadata = new Q2(), this.buffer = new Uint8Array(), this.Xc = new TextDecoder("utf-8"), this.Zc().then((t3) => {
      t3 && t3.ac() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Yc.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Kc() {
    return await this.getMetadata(), this.Zc();
  }
  async Zc() {
    const t2 = await this.tu();
    if (t2 === null)
      return null;
    const e = this.Xc.decode(t2), n = Number(e);
    isNaN(n) && this.eu(`length string (${e}) is not valid number`);
    const s = await this.nu(n);
    return new Pc2(JSON.parse(s), t2.length + n);
  }
  su() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async tu() {
    for (; this.su() < 0; ) {
      if (await this.iu())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.su();
    t2 < 0 && this.eu("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async nu(t2) {
    for (; this.buffer.length < t2; ) {
      await this.iu() && this.eu("Reached the end of bundle when more is expected.");
    }
    const e = this.Xc.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  eu(t2) {
    throw this.Yc.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async iu() {
    const t2 = await this.Yc.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Iu = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new j(G.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = K2(t3), s = os(n.O) + "/documents", i = {
        documents: e2.map((t4) => ns(n.O, t4))
      }, r = await n.Lr("BatchGetDocuments", s, i), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = hs(n.O, t4);
        o.set(e3.key.toString(), e3);
      });
      const c = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        U2(!!e3), c.push(e3);
      }), c;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new mn(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = Nt.fromPath(e);
      this.mutations.push(new gn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = K2(t3), s = os(n.O) + "/documents", i = {
        writes: e.map((t4) => fs(n.O, t4))
      };
      await n.Mr("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = at.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new j(G.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? nn.updateTime(e) : nn.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(at.min()))
        throw new j(G.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return nn.updateTime(e);
    }
    return nn.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Eu = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.ru = 5, this.ro = new Co(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.ru -= 1, this.ou();
  }
  ou() {
    this.ro.Hr(async () => {
      const t2 = new Iu(this.datastore), e = this.cu(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.uu(t3);
        }));
      }).catch((t3) => {
        this.uu(t3);
      });
    });
  }
  cu(t2) {
    try {
      const e = this.updateFunction(t2);
      return !St(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  uu(t2) {
    this.ru > 0 && this.au(t2) ? (this.ru -= 1, this.asyncQueue.enqueueAndForget(() => (this.ou(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  au(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !En(e);
    }
    return false;
  }
};
var Tu = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = it.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      M2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (M2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new j(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new Q2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = dc2(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Au(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), M2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await Ur(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Ru(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Pu(t2);
  M2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => uc2(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => uc2(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function Pu(t2) {
  return t2.offlineComponents || (M2("FirestoreClient", "Using default OfflineComponentProvider"), await Au(t2, new du())), t2.offlineComponents;
}
async function bu(t2) {
  return t2.onlineComponents || (M2("FirestoreClient", "Using default OnlineComponentProvider"), await Ru(t2, new mu())), t2.onlineComponents;
}
function vu(t2) {
  return Pu(t2).then((t3) => t3.persistence);
}
function Vu(t2) {
  return Pu(t2).then((t3) => t3.localStore);
}
function Su(t2) {
  return bu(t2).then((t3) => t3.remoteStore);
}
function Du(t2) {
  return bu(t2).then((t3) => t3.syncEngine);
}
async function Cu(t2) {
  const e = await bu(t2), n = e.eventManager;
  return n.onListen = Oc2.bind(null, e.syncEngine), n.onUnlisten = $c2.bind(null, e.syncEngine), n;
}
function Nu(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await vu(t2), n = await Su(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = K2(t3);
      return e2.Ko.delete(0), Fo(e2);
    }(n);
  });
}
function xu(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await vu(t2), n = await Su(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = K2(t3);
      e2.Ko.add(0), await Bo(e2), e2.Qo.set("Offline");
    }(n);
  });
}
function ku(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Us.ys(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new j(G.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = dc2(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Vu(t2), e, n)), n.promise;
}
function Ou(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new yu({
      next: (r2) => {
        e2.enqueueAndForget(() => Ic2(t3, o));
        const c = r2.docs.has(n2);
        !c && r2.fromCache ? i.reject(new j(G.UNAVAILABLE, "Failed to get document because the client is offline.")) : c && r2.fromCache && s2 && s2.source === "server" ? i.reject(new j(G.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Rc2(Ae(n2.path), r, {
      includeMetadataChanges: true,
      uc: true
    });
    return pc2(t3, o);
  }(await Cu(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Mu(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await Hr(t3, e2, true), i = new Cc2(e2, s.Ks), r = i.Ic(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = dc2(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Vu(t2), e, n)), n.promise;
}
function $u(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new yu({
      next: (n3) => {
        e2.enqueueAndForget(() => Ic2(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new j(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Rc2(n2, r, {
      includeMetadataChanges: true,
      uc: true
    });
    return pc2(t3, o);
  }(await Cu(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Fu(t2, e) {
  const n = new yu(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    K2(t3).Zo.add(e2), e2.next();
  }(await Cu(t2), n)), () => {
    n.Jc(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      K2(t3).Zo.delete(e2);
    }(await Cu(t2), n));
  };
}
function Bu(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return bu(t3).then((t4) => t4.datastore);
    }(t2);
    new Eu(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function Lu(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new pu(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return gu(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return gu(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Do(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    fu(await Du(t2), i, s);
  });
}
function Uu(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = K2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Kn.getNamedQuery(t4, e2));
  }(await Vu(t2), e));
}
var qu = /* @__PURE__ */ new Map();
function Ku(t2, e, n) {
  if (!n)
    throw new j(G.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function Gu(t2, e, n, s) {
  if (e === true && s === true)
    throw new j(G.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function ju(t2) {
  if (!Nt.isDocumentKey(t2))
    throw new j(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function Qu(t2) {
  if (Nt.isDocumentKey(t2))
    throw new j(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function Wu(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function zu(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new j(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = Wu(t2);
      throw new j(G.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function Hu(t2, e) {
  if (e <= 0)
    throw new j(G.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var Ju = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new j(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new j(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, Gu("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var Yu = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ju({}), this._settingsFrozen = false, t2 instanceof Vt ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new j(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new Vt(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new j(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new j(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ju(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return U2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new j(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = qu.get(t2);
      e && (M2("ComponentProvider", "Removing Datastore"), qu.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Xu(t2, e, n, s = {}) {
  var i;
  const r = (t2 = zu(t2, Yu))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && F2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new j(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new W2(e2, n2));
  }
}
var Zu = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new ea2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Zu(this.firestore, t2, this._key);
  }
};
var ta2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new ta2(this.firestore, t2, this._query);
  }
};
var ea2 = class extends ta2 {
  constructor(t2, e, n) {
    super(t2, e, Ae(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Zu(this.firestore, null, new Nt(t2));
  }
  withConverter(t2) {
    return new ea2(this.firestore, t2, this._path);
  }
};
function na2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), Ku("collection", "path", e), t2 instanceof Yu) {
    const s = _t.fromString(e, ...n);
    return Qu(s), new ea2(t2, null, s);
  }
  {
    if (!(t2 instanceof Zu || t2 instanceof ea2))
      throw new j(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return Qu(s), new ea2(t2.firestore, null, s);
  }
}
function sa2(t2, e) {
  if (t2 = zu(t2, Yu), Ku("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new j(G.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new ta2(t2, null, function(t3) {
    return new Ee(_t.emptyPath(), t3);
  }(e));
}
function ia2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = it.R()), Ku("doc", "path", e), t2 instanceof Yu) {
    const s = _t.fromString(e, ...n);
    return ju(s), new Zu(t2, null, new Nt(s));
  }
  {
    if (!(t2 instanceof Zu || t2 instanceof ea2))
      throw new j(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return ju(s), new Zu(t2.firestore, t2 instanceof ea2 ? t2.converter : null, new Nt(s));
  }
}
function ra2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Zu || t2 instanceof ea2) && (e instanceof Zu || e instanceof ea2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function oa2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof ta2 && e instanceof ta2 && (t2.firestore === e.firestore && Ne(t2._query, e._query) && t2.converter === e.converter);
}
var ca = class {
  constructor() {
    this.hu = Promise.resolve(), this.lu = [], this.fu = false, this.du = [], this._u = null, this.wu = false, this.mu = false, this.gu = [], this.ro = new Co(this, "async_queue_retry"), this.yu = () => {
      const t3 = So();
      t3 && M2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.ro.Yr();
    };
    const t2 = So();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.yu);
  }
  get isShuttingDown() {
    return this.fu;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.pu(), this.Iu(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.fu) {
      this.fu = true, this.mu = t2 || false;
      const e = So();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.yu);
    }
  }
  enqueue(t2) {
    if (this.pu(), this.fu)
      return new Promise(() => {
      });
    const e = new Q2();
    return this.Iu(() => this.fu && this.mu ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.lu.push(t2), this.Eu()));
  }
  async Eu() {
    if (this.lu.length !== 0) {
      try {
        await this.lu[0](), this.lu.shift(), this.ro.reset();
      } catch (t2) {
        if (!ui(t2))
          throw t2;
        M2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.lu.length > 0 && this.ro.Hr(() => this.Eu());
    }
  }
  Iu(t2) {
    const e = this.hu.then(() => (this.wu = true, t2().catch((t3) => {
      this._u = t3, this.wu = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw $("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.wu = false, t3))));
    return this.hu = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.pu(), this.gu.indexOf(t2) > -1 && (e = 0);
    const s = fc2.createAndSchedule(this, t2, e, n, (t3) => this.Tu(t3));
    return this.du.push(s), s;
  }
  pu() {
    this._u && L2();
  }
  verifyOperationInProgress() {
  }
  async Au() {
    let t2;
    do {
      t2 = this.hu, await t2;
    } while (t2 !== this.hu);
  }
  Ru(t2) {
    for (const e of this.du)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Pu(t2) {
    return this.Au().then(() => {
      this.du.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.du)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Au();
    });
  }
  bu(t2) {
    this.gu.push(t2);
  }
  Tu(t2) {
    const e = this.du.indexOf(t2);
    this.du.splice(e, 1);
  }
};
function ua2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var aa2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new Q2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var ha2 = -1;
var la2 = class extends Yu {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new ca(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || wa(this), this._firestoreClient.terminate();
  }
};
function fa2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new j(G.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new j(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function da2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function _a(t2) {
  return t2._firestoreClient || wa(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function wa(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new vt(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Tu(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function ma2(t2, e) {
  ba2(t2 = zu(t2, la2));
  const n = _a(t2), s = t2._freezeSettings(), i = new mu();
  return ya2(n, i, new _u(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function ga(t2) {
  ba2(t2 = zu(t2, la2));
  const e = _a(t2), n = t2._freezeSettings(), s = new mu();
  return ya2(e, s, new wu(s, n.cacheSizeBytes));
}
function ya2(t2, e, n) {
  const s = new Q2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Au(t2, n), await Ru(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === G.FAILED_PRECONDITION || t4.code === G.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function pa2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new j(G.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new Q2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!ri.Vt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await ri.delete(e2);
      }(kr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Ia2(t2) {
  return function(t3) {
    const e = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => Gc2(await Du(t3), e)), e.promise;
  }(_a(t2 = zu(t2, la2)));
}
function Ea(t2) {
  return Nu(_a(t2 = zu(t2, la2)));
}
function Ta(t2) {
  return xu(_a(t2 = zu(t2, la2)));
}
function Aa2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Ra2(t2, e) {
  const n = _a(t2 = zu(t2, la2)), s = new aa2();
  return Lu(n, t2._databaseId, e, s), s;
}
function Pa(t2, e) {
  return Uu(_a(t2 = zu(t2, la2)), e).then((e2) => e2 ? new ta2(t2, null, e2.query) : null);
}
function ba2(t2) {
  if (t2._initialized || t2._terminated)
    throw new j(G.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var va = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new j(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new mt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Va2() {
  return new va("__name__");
}
var Sa2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Sa2(pt.fromBase64String(t2));
    } catch (t3) {
      throw new j(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Sa2(pt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Da = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Ca2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new j(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new j(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return rt(this._lat, t2._lat) || rt(this._long, t2._long);
  }
};
var Na2 = /^__.*__$/;
var xa2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new fn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new ln(t2, this.data, e, this.fieldTransforms);
  }
};
var ka2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new fn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function Oa(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var Ma2 = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.O = n, this.ignoreUndefinedProperties = s, i === void 0 && this.vu(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Vu() {
    return this.settings.Vu;
  }
  Su(t2) {
    return new Ma2(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.O, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Du(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Su({
      path: n,
      Cu: false
    });
    return s.Nu(t2), s;
  }
  xu(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Su({
      path: n,
      Cu: false
    });
    return s.vu(), s;
  }
  ku(t2) {
    return this.Su({
      path: void 0,
      Cu: true
    });
  }
  Ou(t2) {
    return nh(t2, this.settings.methodName, this.settings.Mu || false, this.path, this.settings.$u);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  vu() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.Nu(this.path.get(t2));
  }
  Nu(t2) {
    if (t2.length === 0)
      throw this.Ou("Document fields must not be empty");
    if (Oa(this.Vu) && Na2.test(t2))
      throw this.Ou('Document fields cannot begin and end with "__"');
  }
};
var $a2 = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.O = n || Do(t2);
  }
  Fu(t2, e, n, s = false) {
    return new Ma2({
      Vu: t2,
      methodName: e,
      $u: n,
      path: mt.emptyPath(),
      Cu: false,
      Mu: s
    }, this.databaseId, this.O, this.ignoreUndefinedProperties);
  }
};
function Fa2(t2) {
  const e = t2._freezeSettings(), n = Do(t2._databaseId);
  return new $a2(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Ba(t2, e, n, s, i, r = {}) {
  const o = t2.Fu(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Xa2("Data must be an object, but it was:", o, s);
  const c = Ja2(s, o);
  let u, a;
  if (r.merge)
    u = new gt(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Za2(e, s2, n);
      if (!o.contains(i2))
        throw new j(G.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      sh(t3, i2) || t3.push(i2);
    }
    u = new gt(t3), a = o.fieldTransforms.filter((t4) => u.covers(t4.field));
  } else
    u = null, a = o.fieldTransforms;
  return new xa2(new zt(c), u, a);
}
var La2 = class extends Da {
  _toFieldTransform(t2) {
    if (t2.Vu !== 2)
      throw t2.Vu === 1 ? t2.Ou(`${this._methodName}() can only appear at the top level of your update data`) : t2.Ou(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof La2;
  }
};
function Ua2(t2, e, n) {
  return new Ma2({
    Vu: 3,
    $u: e.settings.$u,
    methodName: t2._methodName,
    Cu: n
  }, e.databaseId, e.O, e.ignoreUndefinedProperties);
}
var qa2 = class extends Da {
  _toFieldTransform(t2) {
    return new Ze(t2.path, new je());
  }
  isEqual(t2) {
    return t2 instanceof qa2;
  }
};
var Ka2 = class extends Da {
  constructor(t2, e) {
    super(t2), this.Bu = e;
  }
  _toFieldTransform(t2) {
    const e = Ua2(this, t2, true), n = this.Bu.map((t3) => Ha2(t3, e)), s = new Qe(n);
    return new Ze(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var Ga2 = class extends Da {
  constructor(t2, e) {
    super(t2), this.Bu = e;
  }
  _toFieldTransform(t2) {
    const e = Ua2(this, t2, true), n = this.Bu.map((t3) => Ha2(t3, e)), s = new ze(n);
    return new Ze(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var ja2 = class extends Da {
  constructor(t2, e) {
    super(t2), this.Lu = e;
  }
  _toFieldTransform(t2) {
    const e = new Je(t2.O, Le(t2.O, this.Lu));
    return new Ze(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function Qa(t2, e, n, s) {
  const i = t2.Fu(1, e, n);
  Xa2("Data must be an object, but it was:", i, s);
  const r = [], o = zt.empty();
  lt(s, (t3, s2) => {
    const c2 = eh(e, t3, n);
    s2 = getModularInstance(s2);
    const u = i.xu(c2);
    if (s2 instanceof La2)
      r.push(c2);
    else {
      const t4 = Ha2(s2, u);
      t4 != null && (r.push(c2), o.set(c2, t4));
    }
  });
  const c = new gt(r);
  return new ka2(o, c, i.fieldTransforms);
}
function Wa2(t2, e, n, s, i, r) {
  const o = t2.Fu(1, e, n), c = [Za2(e, s, n)], u = [i];
  if (r.length % 2 != 0)
    throw new j(G.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    c.push(Za2(e, r[t3])), u.push(r[t3 + 1]);
  const a = [], h = zt.empty();
  for (let t3 = c.length - 1; t3 >= 0; --t3)
    if (!sh(a, c[t3])) {
      const e2 = c[t3];
      let n2 = u[t3];
      n2 = getModularInstance(n2);
      const s2 = o.xu(e2);
      if (n2 instanceof La2)
        a.push(e2);
      else {
        const t4 = Ha2(n2, s2);
        t4 != null && (a.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new gt(a);
  return new ka2(h, l2, o.fieldTransforms);
}
function za2(t2, e, n, s = false) {
  return Ha2(n, t2.Fu(s ? 4 : 3, e));
}
function Ha2(t2, e) {
  if (Ya2(t2 = getModularInstance(t2)))
    return Xa2("Unsupported field value:", e, t2), Ja2(t2, e);
  if (t2 instanceof Da)
    return function(t3, e2) {
      if (!Oa(e2.Vu))
        throw e2.Ou(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Ou(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.Cu && e.Vu !== 4)
      throw e.Ou("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = Ha2(i, e2.ku(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return Le(e2.O, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = ut.fromDate(t3);
      return {
        timestampValue: Jn(e2.O, n)
      };
    }
    if (t3 instanceof ut) {
      const n = new ut(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Jn(e2.O, n)
      };
    }
    if (t3 instanceof Ca2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Sa2)
      return {
        bytesValue: Yn(e2.O, t3._byteString)
      };
    if (t3 instanceof Zu) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Ou(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: ts(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Ou(`Unsupported field value: ${Wu(t3)}`);
  }(t2, e);
}
function Ja2(t2, e) {
  const n = {};
  return ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lt(t2, (t3, s) => {
    const i = Ha2(s, e.Du(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Ya2(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof ut || t2 instanceof Ca2 || t2 instanceof Sa2 || t2 instanceof Zu || t2 instanceof Da);
}
function Xa2(t2, e, n) {
  if (!Ya2(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = Wu(n);
    throw s === "an object" ? e.Ou(t2 + " a custom object") : e.Ou(t2 + " " + s);
  }
}
function Za2(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof va)
    return e._internalPath;
  if (typeof e == "string")
    return eh(t2, e);
  throw nh("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var th = new RegExp("[~\\*/\\[\\]]");
function eh(t2, e, n) {
  if (e.search(th) >= 0)
    throw nh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new va(...e.split("."))._internalPath;
  } catch (s) {
    throw nh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function nh(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let c = `Function ${e}() called with invalid data`;
  n && (c += " (via `toFirestore()`)"), c += ". ";
  let u = "";
  return (r || o) && (u += " (found", r && (u += ` in field ${s}`), o && (u += ` in document ${i}`), u += ")"), new j(G.INVALID_ARGUMENT, c + t2 + u);
}
function sh(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var ih = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Zu(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new rh(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(oh("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var rh = class extends ih {
  data() {
    return super.data();
  }
};
function oh(t2, e) {
  return typeof e == "string" ? eh(t2, e) : e instanceof va ? e._internalPath : e._delegate._internalPath;
}
var ch = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var uh = class extends ih {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new ah(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(oh("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var ah = class extends uh {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var hh = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new ch(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new ah(this._firestore, this._userDataWriter, n.key, n, new ch(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new j(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new ah(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new ch(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new ah(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new ch(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: lh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function lh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function fh(t2, e) {
  return t2 instanceof uh && e instanceof uh ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof hh && e instanceof hh && (t2._firestore === e._firestore && oa2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function dh(t2) {
  if (Pe(t2) && t2.explicitOrderBy.length === 0)
    throw new j(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var _h = class {
};
function wh(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var mh = class extends _h {
  constructor(t2, e, n) {
    super(), this.Uu = t2, this.qu = e, this.Ku = n, this.type = "where";
  }
  _apply(t2) {
    const e = Fa2(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let c;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new j(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          Ch(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Dh(s, t3, n3));
          c = {
            arrayValue: {
              values: e3
            }
          };
        } else
          c = Dh(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || Ch(o, r), c = za2(n2, e2, o, r === "in" || r === "not-in");
      const u = ce.create(i, r, c);
      return function(t4, e3) {
        if (e3.S()) {
          const n4 = ve(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new j(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = be(t4);
          s2 !== null && Nh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new j(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new j(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, u), u;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Uu, this.qu, this.Ku);
    return new ta2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new Ee(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function gh(t2, e, n) {
  const s = e, i = oh("where", t2);
  return new mh(i, s, n);
}
var yh = class extends _h {
  constructor(t2, e) {
    super(), this.Uu = t2, this.Gu = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new j(G.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new j(G.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new ge(e2, n);
      return function(t4, e3) {
        if (be(t4) === null) {
          const n2 = ve(t4);
          n2 !== null && Nh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Uu, this.Gu);
    return new ta2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new Ee(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function ph(t2, e = "asc") {
  const n = e, s = oh("orderBy", t2);
  return new yh(s, n);
}
var Ih = class extends _h {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ju = e, this.Qu = n;
  }
  _apply(t2) {
    return new ta2(t2.firestore, t2.converter, Ce(t2._query, this.ju, this.Qu));
  }
};
function Eh(t2) {
  return Hu("limit", t2), new Ih("limit", t2, "F");
}
function Th(t2) {
  return Hu("limitToLast", t2), new Ih("limitToLast", t2, "L");
}
var Ah = class extends _h {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Wu = e, this.zu = n;
  }
  _apply(t2) {
    const e = Sh(t2, this.type, this.Wu, this.zu);
    return new ta2(t2.firestore, t2.converter, function(t3, e2) {
      return new Ee(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Rh(...t2) {
  return new Ah("startAt", t2, true);
}
function Ph(...t2) {
  return new Ah("startAfter", t2, false);
}
var bh = class extends _h {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Wu = e, this.zu = n;
  }
  _apply(t2) {
    const e = Sh(t2, this.type, this.Wu, this.zu);
    return new ta2(t2.firestore, t2.converter, function(t3, e2) {
      return new Ee(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function vh(...t2) {
  return new bh("endBefore", t2, false);
}
function Vh(...t2) {
  return new bh("endAt", t2, true);
}
function Sh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof ih)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new j(G.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Se(t3))
        if (n3.field.isKeyField())
          r.push(Ut(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Rt(t4))
            throw new j(G.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new j(G.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new me(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = Fa2(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new j(G.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const c = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const u = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof u != "string")
            throw new j(G.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof u}`);
          if (!Ve(t3) && u.indexOf("/") !== -1)
            throw new j(G.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${u}' contains a slash.`);
          const n3 = t3.path.child(_t.fromString(u));
          if (!Nt.isDocumentKey(n3))
            throw new j(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new Nt(n3);
          c.push(Ut(e2, i3));
        } else {
          const t4 = za2(n2, s2, u);
          c.push(t4);
        }
      }
      return new me(c, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Dh(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new j(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Ve(e) && n.indexOf("/") !== -1)
      throw new j(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(_t.fromString(n));
    if (!Nt.isDocumentKey(s))
      throw new j(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Ut(t2, new Nt(s));
  }
  if (n instanceof Zu)
    return Ut(t2, n._key);
  throw new j(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Wu(n)}.`);
}
function Ch(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new j(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new j(G.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Nh(t2, e, n) {
  if (!n.isEqual(e))
    throw new j(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var xh = class {
  convertValue(t2, e = "none") {
    switch (kt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Tt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(At(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Ca2(Tt(t2.latitude), Tt(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Pt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(bt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Et(t2);
    return new ut(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = _t.fromString(t2);
    U2(vs(n));
    const s = new Vt(n.get(1), n.get(3)), i = new Nt(n.popFirst(5));
    return s.isEqual(e) || $(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function kh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var Oh = class extends xh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Sa2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Zu(this.firestore, null, e);
  }
};
var Mh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Fa2(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = $h(t2, this._firestore), i = kh(s.converter, e, n), r = Ba(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, nn.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = $h(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof va ? Wa2(this._dataReader, "WriteBatch.update", i._key, e, n, s) : Qa(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, nn.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = $h(t2, this._firestore);
    return this._mutations = this._mutations.concat(new mn(e._key, nn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new j(G.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function $h(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new j(G.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function Fh(t2) {
  t2 = zu(t2, Zu);
  const e = zu(t2.firestore, la2);
  return Ou(_a(e), t2._key).then((n) => Xh(e, t2, n));
}
var Bh = class extends xh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Sa2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Zu(this.firestore, null, e);
  }
};
function Lh(t2) {
  t2 = zu(t2, Zu);
  const e = zu(t2.firestore, la2), n = _a(e), s = new Bh(e);
  return ku(n, t2._key).then((n2) => new uh(e, s, t2._key, n2, new ch(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function Uh(t2) {
  t2 = zu(t2, Zu);
  const e = zu(t2.firestore, la2);
  return Ou(_a(e), t2._key, {
    source: "server"
  }).then((n) => Xh(e, t2, n));
}
function qh(t2) {
  t2 = zu(t2, ta2);
  const e = zu(t2.firestore, la2), n = _a(e), s = new Bh(e);
  return dh(t2._query), $u(n, t2._query).then((n2) => new hh(e, s, t2, n2));
}
function Kh(t2) {
  t2 = zu(t2, ta2);
  const e = zu(t2.firestore, la2), n = _a(e), s = new Bh(e);
  return Mu(n, t2._query).then((n2) => new hh(e, s, t2, n2));
}
function Gh(t2) {
  t2 = zu(t2, ta2);
  const e = zu(t2.firestore, la2), n = _a(e), s = new Bh(e);
  return $u(n, t2._query, {
    source: "server"
  }).then((n2) => new hh(e, s, t2, n2));
}
function jh(t2, e, n) {
  t2 = zu(t2, Zu);
  const s = zu(t2.firestore, la2), i = kh(t2.converter, e, n);
  return Yh(s, [Ba(Fa2(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, nn.none())]);
}
function Qh(t2, e, n, ...s) {
  t2 = zu(t2, Zu);
  const i = zu(t2.firestore, la2), r = Fa2(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof va ? Wa2(r, "updateDoc", t2._key, e, n, s) : Qa(r, "updateDoc", t2._key, e);
  return Yh(i, [o.toMutation(t2._key, nn.exists(true))]);
}
function Wh(t2) {
  return Yh(zu(t2.firestore, la2), [new mn(t2._key, nn.none())]);
}
function zh(t2, e) {
  const n = zu(t2.firestore, la2), s = ia2(t2), i = kh(t2.converter, e);
  return Yh(n, [Ba(Fa2(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, nn.exists(false))]).then(() => s);
}
function Hh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || ua2(e[o]) || (r = e[o], o++);
  const c = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (ua2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let u, a, h;
  if (t2 instanceof Zu)
    a = zu(t2.firestore, la2), h = Ae(t2._key.path), u = {
      next: (n2) => {
        e[o] && e[o](Xh(a, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = zu(t2, ta2);
    a = zu(n2.firestore, la2), h = n2._query;
    const s2 = new Bh(a);
    u = {
      next: (t3) => {
        e[o] && e[o](new hh(a, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, dh(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new yu(s2), r2 = new Rc2(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => pc2(await Cu(t3), r2)), () => {
      i2.Jc(), t3.asyncQueue.enqueueAndForget(async () => Ic2(await Cu(t3), r2));
    };
  }(_a(a), h, c, u);
}
function Jh(t2, e) {
  return Fu(_a(t2 = zu(t2, la2)), ua2(e) ? e : {
    next: e
  });
}
function Yh(t2, e) {
  return function(t3, e2) {
    const n = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => Fc2(await Du(t3), e2, n)), n.promise;
  }(_a(t2), e);
}
function Xh(t2, e, n) {
  const s = n.docs.get(e._key), i = new Bh(t2);
  return new uh(t2, i, e._key, s, new ch(n.hasPendingWrites, n.fromCache), e.converter);
}
var Zh = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = Fa2(t2);
  }
  get(t2) {
    const e = $h(t2, this._firestore), n = new Oh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new ih(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new ih(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = $h(t2, this._firestore), i = kh(s.converter, e, n), r = Ba(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = $h(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof va ? Wa2(this._dataReader, "Transaction.update", i._key, e, n, s) : Qa(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = $h(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = $h(t2, this._firestore), n = new Bh(this._firestore);
    return super.get(t2).then((t3) => new uh(this._firestore, n, e._key, t3._document, new ch(false, false), e.converter));
  }
};
function tl(t2, e) {
  return Bu(_a(t2 = zu(t2, la2)), (n) => e(new Zh(t2, n)));
}
function el() {
  return new La2("deleteField");
}
function nl() {
  return new qa2("serverTimestamp");
}
function sl(...t2) {
  return new Ka2("arrayUnion", t2);
}
function il(...t2) {
  return new Ga2("arrayRemove", t2);
}
function rl(t2) {
  return new ja2("increment", t2);
}
function ol(t2) {
  return _a(t2 = zu(t2, la2)), new Mh(t2, (e) => Yh(t2, e));
}
function cl(t2, e) {
  _a(t2 = zu(t2, la2));
  const n = typeof e == "string" ? function(t3) {
    try {
      return JSON.parse(t3);
    } catch (t4) {
      throw new j(G.INVALID_ARGUMENT, "Failed to parse JSON:" + t4.message);
    }
  }(e) : e, s = [];
  if (Array.isArray(n.indexes))
    for (const t3 of n.indexes) {
      const e2 = ul(t3, "collectionGroup"), n2 = [];
      if (Array.isArray(t3.fields))
        for (const e3 of t3.fields) {
          const t4 = eh("setIndexConfiguration", ul(e3, "fieldPath"));
          e3.arrayConfig === "CONTAINS" ? n2.push(new Xt(t4, 2)) : e3.order === "ASCENDING" ? n2.push(new Xt(t4, 0)) : e3.order === "DESCENDING" && n2.push(new Xt(t4, 1));
        }
      s.push(new Yt(Yt.UNKNOWN_ID, e2, n2, Zt.empty()));
    }
  return Promise.resolve();
}
function ul(t2, e) {
  if (typeof t2[e] != "string")
    throw new j(G.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    N2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new la2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.5", t2), registerVersion(D2, "3.4.5", "esm2017");
}();
export {
  xh as AbstractUserDataWriter,
  Sa2 as Bytes,
  ha2 as CACHE_SIZE_UNLIMITED,
  ea2 as CollectionReference,
  Zu as DocumentReference,
  uh as DocumentSnapshot,
  va as FieldPath,
  Da as FieldValue,
  la2 as Firestore,
  j as FirestoreError,
  Ca2 as GeoPoint,
  aa2 as LoadBundleTask,
  ta2 as Query,
  _h as QueryConstraint,
  ah as QueryDocumentSnapshot,
  hh as QuerySnapshot,
  ch as SnapshotMetadata,
  ut as Timestamp,
  Zh as Transaction,
  Mh as WriteBatch,
  Vt as _DatabaseId,
  Nt as _DocumentKey,
  et as _EmptyAppCheckTokenProvider,
  z2 as _EmptyAuthCredentialsProvider,
  mt as _FieldPath,
  zu as _cast,
  q2 as _debugAssert,
  yt as _isBase64Available,
  F2 as _logWarn,
  cl as _setIndexConfiguration,
  Gu as _validateIsNotUsedTogether,
  zh as addDoc,
  il as arrayRemove,
  sl as arrayUnion,
  pa2 as clearIndexedDbPersistence,
  na2 as collection,
  sa2 as collectionGroup,
  Xu as connectFirestoreEmulator,
  Wh as deleteDoc,
  el as deleteField,
  Ta as disableNetwork,
  ia2 as doc,
  Va2 as documentId,
  ma2 as enableIndexedDbPersistence,
  ga as enableMultiTabIndexedDbPersistence,
  Ea as enableNetwork,
  Vh as endAt,
  vh as endBefore,
  _a as ensureFirestoreConfigured,
  Yh as executeWrite,
  Fh as getDoc,
  Lh as getDocFromCache,
  Uh as getDocFromServer,
  qh as getDocs,
  Kh as getDocsFromCache,
  Gh as getDocsFromServer,
  da2 as getFirestore,
  rl as increment,
  fa2 as initializeFirestore,
  Eh as limit,
  Th as limitToLast,
  Ra2 as loadBundle,
  Pa as namedQuery,
  Hh as onSnapshot,
  Jh as onSnapshotsInSync,
  ph as orderBy,
  wh as query,
  oa2 as queryEqual,
  ra2 as refEqual,
  tl as runTransaction,
  nl as serverTimestamp,
  jh as setDoc,
  O2 as setLogLevel,
  fh as snapshotEqual,
  Ph as startAfter,
  Rh as startAt,
  Aa2 as terminate,
  Qh as updateDoc,
  Ia2 as waitForPendingWrites,
  gh as where,
  ol as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
